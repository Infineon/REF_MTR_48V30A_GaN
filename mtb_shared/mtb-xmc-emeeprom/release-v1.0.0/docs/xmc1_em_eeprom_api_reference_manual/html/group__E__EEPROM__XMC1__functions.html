<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC1000 Emulated EEPROM Middleware Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC1000 Emulated EEPROM Middleware Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__E__EEPROM__XMC1__functions.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>This section describes the public APIs defined by the Emulated EEPROM. </p>
<p><br />
</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga85da0c37b593a4b19762cead7d1b5128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#ga8b6790c572ddecd512472d2a51282a5b">E_EEPROM_XMC1_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__E__EEPROM__XMC1__functions.html#ga85da0c37b593a4b19762cead7d1b5128">E_EEPROM_XMC1_Init</a> (<a class="el" href="group__E__EEPROM__XMC1__datastructures.html#structE__EEPROM__XMC1__t">E_EEPROM_XMC1_t</a> *const handle_ptr)</td></tr>
<tr class="memdesc:ga85da0c37b593a4b19762cead7d1b5128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes E_EEPROM_XMC1 APP with the associated configuration handle.  <a href="#ga85da0c37b593a4b19762cead7d1b5128">More...</a><br /></td></tr>
<tr class="separator:ga85da0c37b593a4b19762cead7d1b5128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga692c04a49a46a6886e6da5158084b344"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#gaf66c15ce3ed3de7ecb60dd93b4258aae">E_EEPROM_XMC1_OPERATION_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__E__EEPROM__XMC1__functions.html#ga692c04a49a46a6886e6da5158084b344">E_EEPROM_XMC1_Write</a> (uint8_t block_number, uint8_t *data_buffer_ptr)</td></tr>
<tr class="memdesc:ga692c04a49a46a6886e6da5158084b344"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Programs the user defined data block into the flash.  <a href="#ga692c04a49a46a6886e6da5158084b344">More...</a><br /></td></tr>
<tr class="separator:ga692c04a49a46a6886e6da5158084b344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f00e9c779a34b1670d353bccac9adc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#gaf66c15ce3ed3de7ecb60dd93b4258aae">E_EEPROM_XMC1_OPERATION_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__E__EEPROM__XMC1__functions.html#ga5f00e9c779a34b1670d353bccac9adc2">E_EEPROM_XMC1_Read</a> (uint8_t block_number, uint32_t block_offset, uint8_t *data_buffer_ptr, uint32_t length)</td></tr>
<tr class="memdesc:ga5f00e9c779a34b1670d353bccac9adc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the data block contents from flash for the requested block number.  <a href="#ga5f00e9c779a34b1670d353bccac9adc2">More...</a><br /></td></tr>
<tr class="separator:ga5f00e9c779a34b1670d353bccac9adc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a1b6cad582158cbda7b0ebbf1bb459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#gaf66c15ce3ed3de7ecb60dd93b4258aae">E_EEPROM_XMC1_OPERATION_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__E__EEPROM__XMC1__functions.html#ga42a1b6cad582158cbda7b0ebbf1bb459">E_EEPROM_XMC1_StartGarbageCollection</a> (void)</td></tr>
<tr class="memdesc:ga42a1b6cad582158cbda7b0ebbf1bb459"><td class="mdescLeft">&#160;</td><td class="mdescRight"><br />
Executes garbage collection at runtime.  <a href="#ga42a1b6cad582158cbda7b0ebbf1bb459">More...</a><br /></td></tr>
<tr class="separator:ga42a1b6cad582158cbda7b0ebbf1bb459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e571c007dcc3dd35467ece1d9176b69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#gaf66c15ce3ed3de7ecb60dd93b4258aae">E_EEPROM_XMC1_OPERATION_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__E__EEPROM__XMC1__functions.html#ga7e571c007dcc3dd35467ece1d9176b69">E_EEPROM_XMC1_InvalidateBlock</a> (uint8_t block_number)</td></tr>
<tr class="memdesc:ga7e571c007dcc3dd35467ece1d9176b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidate the user defined data block that was written into the flash.  <a href="#ga7e571c007dcc3dd35467ece1d9176b69">More...</a><br /></td></tr>
<tr class="separator:ga7e571c007dcc3dd35467ece1d9176b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a628c89b2d9b53d809b25ff6c9a87c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#ga8b6790c572ddecd512472d2a51282a5b">E_EEPROM_XMC1_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__E__EEPROM__XMC1__functions.html#ga32a628c89b2d9b53d809b25ff6c9a87c">E_EEPROM_XMC1_GetStatus</a> (void)</td></tr>
<tr class="memdesc:ga32a628c89b2d9b53d809b25ff6c9a87c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the status of APP.  <a href="#ga32a628c89b2d9b53d809b25ff6c9a87c">More...</a><br /></td></tr>
<tr class="separator:ga32a628c89b2d9b53d809b25ff6c9a87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97264f12913e5152a61022ac6f5ebf9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__E__EEPROM__XMC1__functions.html#ga97264f12913e5152a61022ac6f5ebf9a">E_EEPROM_XMC1_IsGarbageCollectionNeeded</a> (uint8_t block_number)</td></tr>
<tr class="memdesc:ga97264f12913e5152a61022ac6f5ebf9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the availability of space in flash bank to write the data block.  <a href="#ga97264f12913e5152a61022ac6f5ebf9a">More...</a><br /></td></tr>
<tr class="separator:ga97264f12913e5152a61022ac6f5ebf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca60149d3dbaa6793365429c2c85c90e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#gaf66c15ce3ed3de7ecb60dd93b4258aae">E_EEPROM_XMC1_OPERATION_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__E__EEPROM__XMC1__functions.html#gaca60149d3dbaa6793365429c2c85c90e">E_EEPROM_XMC1_GetPreviousData</a> (uint8_t block_number, uint32_t block_offset, uint8_t *data_buffer_ptr, uint32_t length)</td></tr>
<tr class="memdesc:gaca60149d3dbaa6793365429c2c85c90e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the just previous copy of the block from flash for the requested block number.  <a href="#gaca60149d3dbaa6793365429c2c85c90e">More...</a><br /></td></tr>
<tr class="separator:gaca60149d3dbaa6793365429c2c85c90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga85da0c37b593a4b19762cead7d1b5128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85da0c37b593a4b19762cead7d1b5128">&#9670;&nbsp;</a></span>E_EEPROM_XMC1_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#ga8b6790c572ddecd512472d2a51282a5b">E_EEPROM_XMC1_STATUS_t</a> E_EEPROM_XMC1_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__E__EEPROM__XMC1__datastructures.html#structE__EEPROM__XMC1__t">E_EEPROM_XMC1_t</a> *const&#160;</td>
          <td class="paramname"><em>handle_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes E_EEPROM_XMC1 APP with the associated configuration handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle_ptr</td><td>: Pointer to the handler of the instance for which this API is called<br />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 E_EEPROM_XMC1_STATUS_SUCCESS if initialization is successful else E_EEPROM_XMC1_STATUS_FAILURE<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Configures and initializes the micro-controller flash as an EEPROM associated with the instance handler. Performs three basic functionalities to support EEPROM related operations.<br />
<br />
<ol>
<li>
<b>Detection of active flash bank and process selection</b><br />
 Reading the marker states from first page of each flash bank detects the active bank and the free bank. Detection of active flash bank decides the respective process of state machine<br />
<br />
</li>
<li>
<b>State machine process handling</b><br />
 The state machine process finds free space in the flash for writing user data blocks. If the detection of active bank fails due to corrupted markers, the state machine results in a non recoverable state. If the configuration option "Erase all and recover" is enabled, the state machine process will bring the flash to normal state by formatting the flash banks. Else it stalls the initialization until the flash banks are erased by calling the xmc1_flash low level driver API's.<br />
<br />
</li>
<li>
<b>Building RAM look up table</b><br />
 The RAM lookup table keeps the track of the user data blocks written into flash. The lookup table has the complete information about a configured user data block.<br />
<br />
</li>
</ol>
<b>IMPORTANT : </b> This API must be successfully called before calling any other E_EEPROM_XMC1 API.<br />
 </dd></dl>

</div>
</div>
<a id="ga692c04a49a46a6886e6da5158084b344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga692c04a49a46a6886e6da5158084b344">&#9670;&nbsp;</a></span>E_EEPROM_XMC1_Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#gaf66c15ce3ed3de7ecb60dd93b4258aae">E_EEPROM_XMC1_OPERATION_STATUS_t</a> E_EEPROM_XMC1_Write </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_buffer_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
Programs the user defined data block into the flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_number</td><td>: Block ID Name/Number configured in the block table. Use the names defined in <a class="el" href="group__E__EEPROM__XMC1__datastructures.html#structE__EEPROM__XMC1__BLOCK__t">E_EEPROM_XMC1_BLOCK_t</a> configuration structure array. </td></tr>
    <tr><td class="paramname">data_buffer_ptr</td><td>: Pointer to the user data buffer which need to be stored in flash</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if the write operation is successful<br />
 E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED, if APP initialization is not completed or flash is busy<br />
 E_EEPROM_XMC1_OPERATION_STATUS_MEMORY_BANK_FULL, if no space available in flash bank to write the block<br />
 E_EEPROM_XMC1_OPERATION_STATUS_FAILURE, if write failed due to internal flash errors<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>The requested data block is written into the flash immediately, only when free space is available in flash bank. On non availability of space in active flash bank, the write gets delayed due to Garbage Collection. <b>IMPORTANT : </b> This API shall be called only after the successful completion of <a class="el" href="group__E__EEPROM__XMC1__functions.html#ga85da0c37b593a4b19762cead7d1b5128" title="Initializes E_EEPROM_XMC1 APP with the associated configuration handle. ">E_EEPROM_XMC1_Init()</a> API.<br />
 While flash programming operation is in progress, the flash array will be busy and no access to flash is possible. Hence all other critical functionalities shall be done prior to the execution of this function.</dd></dl>
<p><b>NOTE :</b><br />
 It is advised to call this API when the APP in is IDLE state. This can be checked by calling <a class="el" href="group__E__EEPROM__XMC1__functions.html#ga32a628c89b2d9b53d809b25ff6c9a87c" title="Checks the status of APP. ">E_EEPROM_XMC1_GetStatus()</a> API and verifying the status.<br />
<br />
 <b>Related APIs : </b><br />
 None<br />
<br />
</p>

</div>
</div>
<a id="ga5f00e9c779a34b1670d353bccac9adc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f00e9c779a34b1670d353bccac9adc2">&#9670;&nbsp;</a></span>E_EEPROM_XMC1_Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#gaf66c15ce3ed3de7ecb60dd93b4258aae">E_EEPROM_XMC1_OPERATION_STATUS_t</a> E_EEPROM_XMC1_Read </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_buffer_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the data block contents from flash for the requested block number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_number</td><td>: Block ID Name/Number configured in the block table. Use the names defined in <a class="el" href="group__E__EEPROM__XMC1__datastructures.html#structE__EEPROM__XMC1__BLOCK__t">E_EEPROM_XMC1_BLOCK_t</a> configuration structure array. </td></tr>
    <tr><td class="paramname">block_offset</td><td>: Offset position to start the read operation<br />
 Range [0 - (Block size - 1)] </td></tr>
    <tr><td class="paramname">data_buffer_ptr</td><td>: Pointer to the data buffer where data has to be stored after read </td></tr>
    <tr><td class="paramname">length</td><td>: Number of the data block elements to be read from the FLASH<br />
 Range [1 - (block size - block_offset)]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if read operation from flash is successful<br />
 E_EEPROM_XMC1_OPERATION_STATUS_FAILURE, if read failed due to ECC errors<br />
 E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED, if APP initialization is not completed or flash is busy<br />
 E_EEPROM_XMC1_OPERATION_STATUS_INCONSISTENT_BLOCK, if the targeted block was not written properly<br />
 E_EEPROM_XMC1_OPERATION_STATUS_INVALID_BLOCK, if the targeted block was invalidated<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Reads the data elements starting from the specified offset location. The number of elements read from the flash is equal to the length specified as input parameter.</dd></dl>
<p><b>IMPORTANT : </b> This API do not perform any CRC verification for the read data.</p>
<p><b>NOTE :</b><br />
 If the flash is in busy state, the read will not be accepted. </p>

</div>
</div>
<a id="ga42a1b6cad582158cbda7b0ebbf1bb459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42a1b6cad582158cbda7b0ebbf1bb459">&#9670;&nbsp;</a></span>E_EEPROM_XMC1_StartGarbageCollection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#gaf66c15ce3ed3de7ecb60dd93b4258aae">E_EEPROM_XMC1_OPERATION_STATUS_t</a> E_EEPROM_XMC1_StartGarbageCollection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><br />
Executes garbage collection at runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if garbage collection is successful<br />
 Else return E_EEPROM_XMC1_OPERATION_STATUS_FAILURE on internal flash errors<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Performs an explicit Garbage collection any time during the execution of APP. The function is accepted only if the E_EEPROM_XMC1 is in IDLE state.</dd></dl>
<p><b>NOTE :</b><br />
 If the flash is busy this will not be processed. It will check for any read write or erase errors and if any errors present it will return error. </p>

</div>
</div>
<a id="ga7e571c007dcc3dd35467ece1d9176b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e571c007dcc3dd35467ece1d9176b69">&#9670;&nbsp;</a></span>E_EEPROM_XMC1_InvalidateBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#gaf66c15ce3ed3de7ecb60dd93b4258aae">E_EEPROM_XMC1_OPERATION_STATUS_t</a> E_EEPROM_XMC1_InvalidateBlock </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalidate the user defined data block that was written into the flash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_number</td><td>: Block ID Name/Number configured in the block table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if the write operation is successful<br />
 E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED, if APP initialization is not completed or flash is busy<br />
 E_EEPROM_XMC1_OPERATION_STATUS_MEMORY_BANK_FULL, if no space available in flash bank to write the block<br />
 E_EEPROM_XMC1_OPERATION_STATUS_FAILURE, else failed due to internal flash errors<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>The invalidated block is written into the flash immediately, only when free space is available in flash bank. On non availability of space in active flash bank, the invalidate write gets delayed due to Garbage Collection. <b>IMPORTANT : </b> This API shall be called only after the successful completion of <a class="el" href="group__E__EEPROM__XMC1__functions.html#ga85da0c37b593a4b19762cead7d1b5128" title="Initializes E_EEPROM_XMC1 APP with the associated configuration handle. ">E_EEPROM_XMC1_Init()</a> API.<br />
 While flash programming operation is in progress, the flash array will be busy and no access to flash is possible. Hence all other critical functionalities shall be done prior to the execution of this function.</dd></dl>
<p><b>NOTE :</b><br />
 It is advised to call this API when the APP in is IDLE state. This can be checked by calling <a class="el" href="group__E__EEPROM__XMC1__functions.html#ga32a628c89b2d9b53d809b25ff6c9a87c" title="Checks the status of APP. ">E_EEPROM_XMC1_GetStatus()</a> API and verifying the status.<br />
<br />
 <b>Related APIs : </b><br />
 None<br />
<br />
</p>

</div>
</div>
<a id="ga32a628c89b2d9b53d809b25ff6c9a87c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32a628c89b2d9b53d809b25ff6c9a87c">&#9670;&nbsp;</a></span>E_EEPROM_XMC1_GetStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#ga8b6790c572ddecd512472d2a51282a5b">E_EEPROM_XMC1_STATUS_t</a> E_EEPROM_XMC1_GetStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the status of APP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 E_EEPROM_XMC1_STATUS_IDLE, if APP is in IDLE state to accept any request<br />
 E_EEPROM_XMC1_STATUS_FAILURE, if any previous operation on APP failed due to some internal error<br />
 E_EEPROM_XMC1_STATUS_BUSY, Else APP is in busy state because of flash operations<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>Read the current status of APP. </dd></dl>

</div>
</div>
<a id="ga97264f12913e5152a61022ac6f5ebf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97264f12913e5152a61022ac6f5ebf9a">&#9670;&nbsp;</a></span>E_EEPROM_XMC1_IsGarbageCollectionNeeded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool E_EEPROM_XMC1_IsGarbageCollectionNeeded </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the availability of space in flash bank to write the data block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_number</td><td>: Block ID Name/Number configured in the block table. Use the names defined in <a class="el" href="group__E__EEPROM__XMC1__datastructures.html#structE__EEPROM__XMC1__BLOCK__t">E_EEPROM_XMC1_BLOCK_t</a> configuration structure array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 true, if the bank has no space to write the requested block, else returns false.</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>During any time of the execution,the need for Garbage collection can be decided by calling this API. This will help to save time in the runtime write process which triggers a garbage collection automatically.</dd></dl>
<p><b>IMPORTANT : </b> This API shall be called only after the successful completion of <a class="el" href="group__E__EEPROM__XMC1__functions.html#ga85da0c37b593a4b19762cead7d1b5128" title="Initializes E_EEPROM_XMC1 APP with the associated configuration handle. ">E_EEPROM_XMC1_Init()</a> API.<br />
</p>
<p><b>NOTE :</b><br />
 After initialization of the APP, calling this API can decide the need for Garbage collection. If this API returns true an explicit garbage collection can be done by calling the API <a class="el" href="group__E__EEPROM__XMC1__functions.html#ga42a1b6cad582158cbda7b0ebbf1bb459" title=" Executes garbage collection at runtime. ">E_EEPROM_XMC1_StartGarbageCollection()</a>. </p>

</div>
</div>
<a id="gaca60149d3dbaa6793365429c2c85c90e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca60149d3dbaa6793365429c2c85c90e">&#9670;&nbsp;</a></span>E_EEPROM_XMC1_GetPreviousData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__E__EEPROM__XMC1__enumerations.html#gaf66c15ce3ed3de7ecb60dd93b4258aae">E_EEPROM_XMC1_OPERATION_STATUS_t</a> E_EEPROM_XMC1_GetPreviousData </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>block_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>block_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data_buffer_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the just previous copy of the block from flash for the requested block number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block_number</td><td>: Block ID Name/Number configured in the block table. Use the names defined in <a class="el" href="group__E__EEPROM__XMC1__datastructures.html#structE__EEPROM__XMC1__BLOCK__t">E_EEPROM_XMC1_BLOCK_t</a> configuration structure array. </td></tr>
    <tr><td class="paramname">block_offset</td><td>: Offset position to start the read operation<br />
 Range [0 - (Block size - 1)] </td></tr>
    <tr><td class="paramname">data_buffer_ptr</td><td>: Pointer to the data buffer where data has to be stored after read </td></tr>
    <tr><td class="paramname">length</td><td>: Number of the data block elements to be read from the FLASH<br />
 Range [1 - (block size - block_offset)]</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><br />
 E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if read operation from flash is successful<br />
 E_EEPROM_XMC1_OPERATION_STATUS_FAILURE, if read failed due to ECC errors<br />
 E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED, if APP initialization is not completed or flash is busy<br />
 E_EEPROM_XMC1_OPERATION_STATUS_INCONSISTENT_BLOCK, if the targeted block was not written properly<br />
 E_EEPROM_XMC1_OPERATION_STATUS_INVALID_BLOCK, if the targeted block was invalidated<br />
</dd></dl>
<dl class="section user"><dt>Description:</dt><dd>It is useful when the latest write is interrupted due to power failures and flash errors. If a block read results in error, calling this API will search for the very next previous copy in the same bank. If the block is available then the user buffer will be filled with the data as per the requested length and offset. If the just previous copy of the data block is also inconsistent or invalid, no search will be done further.</dd></dl>
<p><b>IMPORTANT : </b> This API do not perform any CRC verification for the read data.</p>
<p><b>NOTE :</b><br />
 If the flash is in busy state, the read will not be accepted. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC1000 Emulated EEPROM Middleware Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
