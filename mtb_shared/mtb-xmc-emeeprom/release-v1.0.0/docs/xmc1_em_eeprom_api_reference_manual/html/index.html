<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>XMC1000 Emulated EEPROM Middleware Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">XMC1000 Emulated EEPROM Middleware Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Em_EEPROM Middleware Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Emulated EEPROM (Em_EEPROM) middleware emulates an EEPROM storage in XMC1000 internal flash memory. The Em_EEPROM middleware operates on the top of the flash driver included in the XMCLib CAT3 Peripheral Driver Library.</p>
<p>Use the Em_EEPROM to store non-volatile data on a target device when increasing flash memory endurance is required.</p>
<p>Please note the Internal Flash reserved by EEPROM middleware when using this asset.</p>
<p><b>Features:</b></p><ul>
<li>EEPROM-Like Non-Volatile Storage</li>
<li>Easy to use Read and Write</li>
</ul>
<h1><a class="anchor" id="section_em_eeprom_general_description"></a>
General Description</h1>
<p>The XMC1000 emulated EEPROM support is provided with the APIs described below.</p>
<p>It should be noted that the non-volatile memory required to store the EEPROM Data is mapped to Internal Flash. In the XMC 1xxx emulated EEPROM Middleware the Flash region required for EEPROM is allocated at the very End of Internal Flash. It is advisable for user(s) of emulated EEPROM to update (modify) their Linker file (script) to reduce the amount of Flash available for code and initialized data.</p>
<h1><a class="anchor" id="section_em_eeprom_linker_script_update"></a>
Linker Script Updates</h1>
<p>It should be noted that the non-volatile memory required to store the EEPROM Data is mapped to Internal Flash. In the XMC 1xxx emulated EEPROM Middleware the Flash region required for EEPROM is allocated at the very End of Internal Flash. The amount of Flash space reserved can be calculated using the macro: E_EEPROM_XMC1_FLASH_TOTAL_SIZE an internal usage macro defined in code. It is advisable for user(s) of emulated EEPROM to update (modify) their Linker file (script) to reduce the amount of Flash available for code and initialed data by the size reserved for EEPROM size desired by application. This will remove the mapped region of Flash form being used for code or initialized data. When properly updated linker script is used and if the user application grows such that it overlaps the Flash region utilized by EEPROM, there will linking errors during the build.</p>
<p>For the Kit/XMC device you are using, please select the proper Linker script. For Infineon ModusToolbox targets, the GCC_ARM and ARM linker scripts are present in target for the kit under TOOLCHAIN_GCC_ARM and TOOLCHAIN_ARM. For IAR, please make a copy of the IAR linker script from the IAR toolchain and edit it for the Project using XMC1xxx Emulated EEPROM. Note - the ModusToolBox allows use of custom Linker script by editing in Makefile the tag LINKER_SCRIPT=&lt;path to custom linker script&gt;.</p>
<p>Examples of how the linker scripts be modified is provided below. Assumption for the explanation of Linker scripts changes is that the Flash reserved for EEPROM is 4 KBytes (0x1000). For user required EEPROM size please determine the size of Flash needed to be reserved from the the output of macro: E_EEPROM_XMC1_FLASH_TOTAL_SIZE for given EEPROM size and make appropriate changes..</p>
<p>Example of GCC_ARM Linker script for XMC1200x0200 Kit/Device (XMC1200x0200.ld):</p>
<p>Original Linker script Memory map and sections:</p>
<div class="fragment"><div class="line">MEMORY</div><div class="line">{</div><div class="line"></div><div class="line">    FLASH(RX) : ORIGIN = 0x10001000, LENGTH = 0x32000</div><div class="line"></div><div class="line">    SRAM(!RX) : ORIGIN = 0x20000000, LENGTH = 0x4000</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Modified Linker script Memory map (4 KBytes reserved for EEPROM):</p>
<div class="fragment"><div class="line">MEMORY</div><div class="line">{</div><div class="line"></div><div class="line">   FLASH(RX) : ORIGIN = 0x10001000, LENGTH = 0x31000</div><div class="line"></div><div class="line">   SRAM(!RX) : ORIGIN = 0x20000000, LENGTH = 0x4000</div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p>Example of ARM Linker script for XMC1200x0200 Kit/Device (XMC1200x0200.sct):</p>
<p>Original Linker Memory map:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define __ROM_BASE     0x10001000</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define __ROM_SIZE     0x00032000</span></div></div><!-- fragment --><p>Modified Linker Memory map (4 KBytes reserved for EEPROM):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define __ROM_BASE     0x10001000</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define __ROM_SIZE     0x00031000</span></div></div><!-- fragment --><p>Example of IAR Linker script for XMC1200x0200 Kit/Device (XMC1200xxxxx200.icf):</p>
<p>Original Linker Memory map:</p>
<div class="fragment"><div class="line">define symbol __ICFEDIT_region_ROM_start__ = 0x10001000;</div><div class="line"></div><div class="line">define symbol __ICFEDIT_region_ROM_end__   = 0x10032FFF;</div><div class="line"></div><div class="line">define symbol __ICFEDIT_region_RAM_start__ = 0x20000000;</div><div class="line"></div><div class="line">define symbol __ICFEDIT_region_RAM_end__   = 0x20003FFF;</div></div><!-- fragment --><p>Modified Linker Memory map (4 KBytes reserved for EEPROM):</p>
<div class="fragment"><div class="line">define symbol __ICFEDIT_region_ROM_start__ = 0x10001000;</div><div class="line"></div><div class="line">define symbol __ICFEDIT_region_ROM_end__   = 0x10031FFF;</div><div class="line"></div><div class="line">define symbol __ICFEDIT_region_RAM_start__ = 0x20000000;</div><div class="line"></div><div class="line">define symbol __ICFEDIT_region_RAM_end__   = 0x20003FFF;</div></div><!-- fragment --><h1><a class="anchor" id="section_em_eeprom_app_usage"></a>
Application Configuration and API Usage</h1>
<p>The XMC1 Emulated EEPROM asset can be used to store non-volatile data in Flash with improved resiliency. In XMC1 emulated eeprom is stored in Flash at the very end. When compiling the XMC1 eeprom asset the macro: E_EEPROM_XMC1_FLASH_EEPROM_SIZE has to be defined to the size of the EEPROM region required. This definition can be provided through the EEPROM Personality in ModusToolbox or passed as DEFINE+=E_EEPROM_XMC1_FLASH_EEPROM_SIZE="desired size". Note - the size of EEPROM should be larger than the sum of All the blocks that are configured in the XMC1 EEPROM configuration structure. This will allow multiple updates in current flash bank before need for Garbage collection to next bank. This improves the flash resiliency. The region of flash that will be used for storage should be erased before the first time it is used to map EEPROM data. After using region for EEPROM, this region should not be erased unless it is explicitly desired to get rid of previously stored EEPROM data.</p>
<p>The XMC1 EEPROM has a complex configuration and handle data structure which passes in the initial configuration information and it also stores the run-time data needed for subsequent API execution. The XMC Configuration data structure is:</p>
<p>Data structure to configure the APP properties. Use <a class="el" href="group__E__EEPROM__XMC1__datastructures.html#structE__EEPROM__XMC1__t">E_EEPROM_XMC1_t</a> type for accessing the members * typedef struct E_EEPROM_XMC1 { <a class="el" href="group__E__EEPROM__XMC1__datastructures.html#structE__EEPROM__XMC1__BLOCK__t" title="Data structure to configure the Data Block parameters. ">E_EEPROM_XMC1_BLOCK_t</a> *block_config_ptr; // **&lt; Pointer to user block configurations *</p>
<p><a class="el" href="group__E__EEPROM__XMC1__datastructures.html#structE__EEPROM__XMC1__DATA__t" title="Data structure to hold the complete state data information of Emulation APP (Run Time Handler) ...">E_EEPROM_XMC1_DATA_t</a> *data_ptr; // **&lt; Pointer to the state variable data structure *</p>
<p>#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED</p>
<p>CRC_SW_t* const crc_handle_ptr; // **&lt; CRC APP handle pointer*</p>
<p>#endif</p>
<p>E_EEPROM_XMC1_STATUS_t state; // **&lt; Current state of the APP instance*</p>
<p>const uint8_t block_count; // **&lt; Number of configured user data blocks *</p>
<p>const uint8_t erase_all_auto_recovery; // **&lt; Erase Complete emulation area and recover to default state *</p>
<p>const uint8_t data_block_crc; // **&lt; Allow to calculate CRC for each data block on write *</p>
<p>const uint8_t garbage_collection; // **&lt; Enables garbage collection when no space available for new write*</p>
<p>} <a class="el" href="group__E__EEPROM__XMC1__datastructures.html#structE__EEPROM__XMC1__t" title="Data structure to configure the APP properties. ">E_EEPROM_XMC1_t</a>;</p>
<p>The application should decide the number of blocks that are needed by it (block_count) and provide 2 arrays of size block_count, namely: block_config_ptr[block_count] and data_ptr[block_count]. Note: the maximum block_count supported is 10.</p>
<p>The first array block_config_ptr[block_count] is the configuration information of "block number" and "size" for each block in EEPROM. Note the Size of EEPROM (E_EEPROM_XMC1_FLASH_EEPROM_SIZE) provided by Personality/Define via Makefile should definitely be much larger than the sum of All the block sizes defined in this configuration data structure. Giving a much larger value will reserve more Flash at the end of Flash block but will increase the flash resiliency. The maximum block size size supported is 32 KBytes bytes and the minimum is 1 byte.</p>
<p>The configuration parameter "crc_handle_ptr" can be set to "CRC_SW_0" to use the CRC sw bundled with the asset if CRC is to be enabled.</p>
<p>The data structure parameter: state is Not a configuration parameter.</p>
<p>The Configuration parameter "block_count" denotes the number of user "blocks" Note XMC1 API support read/write only on block basis.</p>
<p>The configuration parameter: erase_all_auto_recovery" should be usually 0 (off). It can be used to erase Flash but should Not be set (1) during regular execution otherwise EEPROM data will be lost on every reboot.</p>
<p>The configuration parameter: data_black_crc, should be set if CRC protection is required. Note - when setting this, the "crc_handle_ptr" should also be enabled.</p>
<p>The configuration parameter: garbage_collection, when set to 1, will enable Automatic garbage collection. If user does Not want automatic garbage collection, then they have to explicitly check in run time code, whether garbage collection is needed and explicitly call it.</p>
<p>Typical EEPROM asset API sequence can be: E_EEPROM_XMC1_Init(&amp;E_EEPROM_XMC1_handle); and then read/write APIs: E_EEPROM_XMC1_Write(blockNum, data_wbuffer); E_EEPROM_XMC1_Read(blockNum, 0U, data_rbuffer, block_size); </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>XMC1000 Emulated EEPROM Middleware Library</b> by <b>Cypress Semiconductor Corporation</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
