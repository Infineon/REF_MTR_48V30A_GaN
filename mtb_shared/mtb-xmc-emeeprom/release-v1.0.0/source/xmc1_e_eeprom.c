/******************************************************************************
 * File Name:   e_eeprom_xmc1.c
 *
 * Description: This sourcefile implements the necessary APIs to use the flash
 * memory as emulated EEPROM in XMC1000 MCUs.
 *
 * Related Document: See README.md
 *
 ******************************************************************************
 *
 * Copyright (c) 2015-2021, Infineon Technologies AG
 * All rights reserved.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *****************************************************************************/

/*****************************************************************************
 * HEADER FILES
 ****************************************************************************/
#include "xmc1_e_eeprom.h"

#if UC_FAMILY == XMC1

/*****************************************************************************
 * MACROS
 ****************************************************************************/
/* Define WEAK attribute */
#if !defined(__WEAK)
#if defined ( __CC_ARM )
#define __WEAK __attribute__ ((weak))
#elif defined ( __ICCARM__ )
#define __WEAK __weak
#elif defined ( __GNUC__ )
#define __WEAK __attribute__ ((weak))
#elif defined ( __TASKING__ )
#define __WEAK __attribute__ ((weak))
#endif
#endif

/* Garbage Collection procedure States */
#define E_EEPROM_XMC1_GC_UNINT             (0x0U)
#define E_EEPROM_XMC1_GC_COPY_START        (0x1U)
#define E_EEPROM_XMC1_GC_READ_NXTBLOCK     (0x2U)
#define E_EEPROM_XMC1_GC_ERASE_PREV_BANK   (0x3U)
#define E_EEPROM_XMC1_GC_REQUESTED         (0x4U)
#define E_EEPROM_XMC1_GC_COPY_WRITE        (0x5U)
#define E_EEPROM_XMC1_GC_COPY_END          (0x6U)
#define E_EEPROM_XMC1_GC_NEXT_BANK_VALID   (0x7U)
#define E_EEPROM_XMC1_GC_MARK_END_ERASE1   (0x8U)
#define E_EEPROM_XMC1_GC_FAIL              (0x9U)
#define E_EEPROM_XMC1_GC_IDLE              (0xAU)

/* Prepare DFLASH states states */
#define E_EEPROM_XMC1_PREPFLASH_FF         (0x1U)
#define E_EEPROM_XMC1_PREPFLASH_2F         (0x4U)
#define E_EEPROM_XMC1_PREPFLASH_2E         (0x5U)


/* Cache Update states */ 
#define E_EEPROM_XMC1_CACHE_IDLE           (0U)
#define E_EEPROM_XMC1_CACHE_EMPTY_BLOCK    (1U)
#define E_EEPROM_XMC1_CACHE_NEXT_BLK       (2U)
#define E_EEPROM_XMC1_CACHE_UPDATE_DONE    (4U)

/* Bank BLOCK values, used to store current status of the DFLASH */
#define E_EEPROM_XMC1_ALL_ONES             ((uint32_t)0xFFFFFFFFU)
#define E_EEPROM_XMC1_ALL_ZEROS            ((uint32_t)0x00000000U)
#define E_EEPROM_XMC1_START_BIT            (0x80U)
#define E_EEPROM_XMC1_VALID_BIT            (0x40U)
#define E_EEPROM_XMC1_CRC_BIT              (0x10U)
#define E_EEPROM_XMC1_VALID_MASK           ((uint32_t)(0x00004000U))
#define E_EEPROM_XMC1_CRC_MASK             ((uint32_t)(0x00001000U))

/* Internal Block status macros for implementation*/
#define E_EEPROM_XMC1_BLOCK1_DATA_SIZE     (12U)
#define E_EEPROM_XMC1_BLOCK2_DATA_SIZE     (14U)
#define E_EEPROM_XMC1_8BIT_ALL_ONE         (0xFFU)
#define E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND  ((uint32_t)(0xFFU))
#define E_EEPROM_XMC1_CRC_SHIFT            (16U)
#define E_EEPROM_XMC1_DUMMY_CRC            (0xA5A50000U)
#define E_EEPROM_XMC1_MASK_CRC             (0xFFFF0000U)

/* Bank BLOCK offsets */
#define E_EEPROM_XMC1_NEXT_VALID_OFFSET    (0U)
#define E_EEPROM_XMC1_BEGIN_OFFSET         (E_EEPROM_XMC1_FLASH_BLOCK_SIZE)
#define E_EEPROM_XMC1_END_OF_COPY_OFFSET   (E_EEPROM_XMC1_FLASH_BLOCK_SIZE * 2U)
#define E_EEPROM_XMC1_END_ERASE_OFFSET     (E_EEPROM_XMC1_FLASH_BLOCK_SIZE * 3U)
#define E_EEPROM_XMC1_DATA_BLOCK_OFFSET    (E_EEPROM_XMC1_FLASH_BLOCK_SIZE * 16U)
#define E_EEPROM_XMC1_BLOCK1_DATA_OFFSET   (4U)
#define E_EEPROM_XMC1_BLOCK2_DATA_OFFSET   (2U)

#define E_EEPROM_XMC1_BLOCK_WRITE_IDLE     (0U)
#define E_EEPROM_XMC1_FIRST_BLOCK_WRITE    (1U)
#define E_EEPROM_XMC1_NEXT_BLOCK_WRITE     (2U)
#define E_EEPROM_XMC1_LAST_BLOCK_WRITE     (3U)

/* States to monitor Garbage Collection completion, if it was interrupted earlier due to reset */
#define E_EEPROM_XMC1_INIT_NORMAL1         (0x2EU) /* Bank0 = VALID        BANK 1 = ERASED */
#define E_EEPROM_XMC1_INIT_DATA_COPY1      (0x2AU) /* Bank0 = VALID        BANK 1 = COPY ON-GOING */
#define E_EEPROM_XMC1_INIT_COPY_DONE2      (0x0AU) /* Bank0 = COPY COMPLETED  BANK 1 = COPY ON-GOING */
#define E_EEPROM_XMC1_INIT_NEXT_VALID2     (0x02U) /* Bank0 = COPY COMPLETED  BANK 1 = VALID */
#define E_EEPROM_XMC1_INIT_END_ERASE2      (0xF2U) /* Bank0 = ERASE ON-GOING  BANK 1 = VALID */

#define E_EEPROM_XMC1_INIT_NORMAL2         (0xE2U) /* Bank1 = VALID        BANK 0 = ERASED */
#define E_EEPROM_XMC1_INIT_DATA_COPY2      (0xA2U) /* Bank1 = VALID        BANK 0 = COPY ON-GOING */
#define E_EEPROM_XMC1_INIT_COPY_DONE1      (0xA0U) /* Bank1 = COPY COMPLETED  BANK 0 = COPY ON-GOING */
#define E_EEPROM_XMC1_INIT_NEXT_VALID1     (0x20U) /* Bank1 = COPY COMPLETED  BANK 0 = VALID */
#define E_EEPROM_XMC1_INIT_END_ERASE1      (0x2FU) /* Bank1 = ERASE ON-GOING  BANK 0 = VALID */

#define E_EEPROM_XMC1_INIT_ALL_ERASED      (0xFFU)

#define E_EEPROM_XMC1_INIT_STATE_2D        (0x2DU)
#define E_EEPROM_XMC1_INIT_STATE_D2        (0xD2U)
#define E_EEPROM_XMC1_INIT_STATE_AD        (0xADU)
#define E_EEPROM_XMC1_INIT_STATE_DA        (0xDAU)
#define E_EEPROM_XMC1_INIT_STATE_0D        (0x0DU)
#define E_EEPROM_XMC1_INIT_STATE_D0        (0xD0U)
#define E_EEPROM_XMC1_INIT_STATE_AF        (0xAFU)
#define E_EEPROM_XMC1_INIT_STATE_FA        (0xFAU)
#define E_EEPROM_XMC1_INIT_STATE_0F        (0x0FU)
#define E_EEPROM_XMC1_INIT_STATE_F0        (0xF0U)

#define E_EEPROM_XMC1_VALID_STATE          ((uint32_t)(0x20U))
#define E_EEPROM_XMC1_COPY_COMPLETED       ((uint32_t)(0x00U))

#define E_EEPROM_XMC1_MARKER_MAX_SHIFT     ((uint32_t)(4U))
#define E_EEPROM_XMC1_MAX_WORDS_IN_BLOCK   ((uint32_t)(4U))
#define E_EEPROM_XMC1_PAGE1_EXTRA_WORDS    ((uint8_t)(48U))
#define E_EEPROM_XMC1_MARKER_POSITION      ((uint32_t)0x80U)

/** Marker states on Init GC operation */
#define E_EEPROM_XMC1_MB_0                 ((uint32_t)0x00U)
#define E_EEPROM_XMC1_MB_1                 ((uint32_t)0x01U)
#define E_EEPROM_XMC1_MB_WRITTEN           ((uint32_t)0x00U)
#define E_EEPROM_XMC1_MB_ERASED            ((uint32_t)0x0FU)
#define E_EEPROM_XMC1_MB_DIRTY             ((uint32_t)0xDDU)

#define E_EEPROM_XMC1_BOTH_BANKS_VALID     ((uint32_t)0U) /* Both banks have clean markers */
#define E_EEPROM_XMC1_BANK0_INVALID        ((uint32_t)1U) /* Bank 0 is having dirty marker */
#define E_EEPROM_XMC1_BANK1_INVALID        ((uint32_t)2U) /* Bank 1 is having dirty marker */
#define E_EEPROM_XMC1_BOTH_BANKS_INVALID   ((uint32_t)3U) /* Both banks are having dirty markers */

#define E_EEPROM_XMC1_TWO_BYTES            ((uint32_t)0x02U)
#define E_EEPROM_XMC1_TWO_BIT_POS          ((uint32_t)0x02U)
#define E_EEPROM_XMC1_FOUR_BYTES           ((uint32_t)0x04U)
#define E_EEPROM_XMC1_EIGHT_BYTES          ((uint32_t)0x08U)
#define E_EEPROM_XMC1_EIGHT_BIT_POS        ((uint32_t)0x08U)

#define E_EEPROM_XMC1_EXECUTE_CACHE_UPDATE (0x0U)
#define E_EEPROM_XMC1_EXECUTE_PREP_FLASH   (0x1U)
#define E_EEPROM_XMC1_EXECUTE_GC_STATE     (0x2U)

/** Internal limits bounds */
#define E_EEPROM_XMC1_MAX_BLOCK_COUNT      (10u)
#define E_EEPROM_XMC1_MAX_BLOCK_SIZE       (0x8000u)


/*****************************************************************************
 * GLOBAL DATA
 ****************************************************************************/
E_EEPROM_XMC1_t *e_eeprom_xmc1_handle;

/*****************************************************************************
 * LOCAL ROUTINES
 ****************************************************************************/
static void E_EEPROM_XMC1_lWriteSingleBlock(uint32_t const address, const uint32_t *const data);
static void E_EEPROM_XMC1_lReadSingleBlock(uint32_t const address, uint32_t *const data);
static void E_EEPROM_XMC1_lWriteSinglePage(uint32_t const address, const uint32_t *const data);
static void E_EEPROM_XMC1_lEraseSinglePage(uint32_t const address);
static uint32_t E_EEPROM_XMC1_lReadSingleWord(uint32_t const address);
static uint32_t E_EEPROM_XMC1_lGetFlashStatus(void);

static void E_EEPROM_XMC1_lInitDirtyStateMachine(void);
static void E_EEPROM_XMC1_lInitNormalStateMachine(void);
static void E_EEPROM_XMC1_lInitllegalStateMachine(void);
static uint32_t E_EEPROM_XMC1_lInitBank0NormalStateMachine(void);
static uint32_t E_EEPROM_XMC1_lInitBank1NormalStateMachine(void);
static uint32_t E_EEPROM_XMC1_lInitOtherNormalStateMachine(void);
static void E_EEPROM_XMC1_lInitGc(const uint32_t  marker_dirty_state);
static void E_EEPROM_XMC1_lInitGcNormalStates(uint32_t current_state, uint32_t next_process);
static void E_EEPROM_XMC1_lInitGcDataCopyState(uint32_t current_state, uint32_t marker_offset);

static void E_EEPROM_XMC1_lPrepareDFlash(void);
static void E_EEPROM_XMC1_lGarbageCollection(void);
static void E_EEPROM_XMC1_lSetMarkerBlockBuffer(void);
static void E_EEPROM_XMC1_lSetMarkerPageBuffer(uint32_t state);
static uint32_t E_EEPROM_XMC1_lReadVerifyMarker(uint32_t bank, uint32_t block);
static void E_EEPROM_XMC1_lErasedDirtyStateRecovery( uint32_t marker_offset);
static uint32_t E_EEPROM_XMC1_lReadMarkerBlocks(void);
static void E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery(uint32_t current_state ,
        uint32_t NextState,
        uint32_t page_addr_select);

static void E_EEPROM_XMC1_lUpdateCache(void);
static void E_EEPROM_XMC1_lEvalBlockStatus(void);
static void E_EEPROM_XMC1_lUpdateCurrBankInfo(void);
static uint32_t E_EEPROM_XMC1_lUpdateCacheBlockRead(void);
static uint32_t E_EEPROM_XMC1_lCacheEmptyBlkEval(uint32_t end_addr);

static uint32_t E_EEPROM_XMC1_lGetFreeDFLASHBlocks(void);
static uint32_t E_EEPROM_XMC1_lGetUsrBlockIndex(uint8_t block_number);
static uint32_t E_EEPROM_XMC1_lGetDFLASHPhysicalBlocks(uint32_t size);
static uint32_t E_EEPROM_XMC1_lGCWrite(uint32_t block_address);
static uint32_t E_EEPROM_XMC1_lEraseBank(uint32_t page_address);

static void E_EEPROM_XMC1_lHandleGcStartCopy(void);
static void E_EEPROM_XMC1_lHandleGcRequested(void);
static void E_EEPROM_XMC1_lHandleGcEndOfCopy(void);
static void E_EEPROM_XMC1_lHandleGcCopyWrite(void);
static void E_EEPROM_XMC1_lHandleGcOtherStates( uint32_t current_state, uint32_t next_state);
static uint32_t E_EEPROM_XMC1_lWriteDataBlock(void);
static uint32_t E_EEPROM_XMC1_lHandleInvalidReq(uint8_t block_number, uint32_t user_block_index);
static uint32_t E_EEPROM_XMC1_lHandleWriteReq(uint8_t block_number, uint8_t* data_buffer_ptr);
static uint32_t E_EEPROM_XMC1_lLocalWrite(uint8_t block_number,
        uint8_t* data_buffer_ptr,
        uint32_t invalidate);
static void E_EEPROM_XMC1_lPopulateNextBlock(uint8_t block_number,
        uint8_t* const user_data_buffer_ptr ,
        uint32_t block_size);
static void E_EEPROM_XMC1_lPopulateFirstBlock(uint8_t block_number, uint8_t* user_data_buffer_ptr, uint32_t block_size);
#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
static E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_lReadBlockCrcStatus(uint8_t block_number,
        uint8_t* data_buffer_ptr,
        uint32_t block_size);
#endif
static uint32_t E_EEPROM_XMC1_lReadBlockContents(uint8_t *data_buffer_ptr, uint32_t length, uint32_t offset);
static uint32_t E_EEPROM_XMC1_lGetPrevData(uint8_t block_number);
static uint32_t E_EEPROM_XMC1_lSearchBlockCopy(uint8_t required_block_number,
        uint32_t read_addr ,
        uint32_t data_sec_start_addr);
/*
 *  These are global functions used only for internal testing purpose.
 *  Application code shall not use these variables by enabling E_EEPROM_XMC1_TEST_HOOK_ENABLE macro definition.
 */
#ifdef E_EEPROM_XMC1_TEST_HOOK_ENABLE
__WEAK void E_EEPROM_XMC1_TEST_HOOK_WriteSingleBlock(uint32_t const address, const uint32_t *const data)
{
}
__WEAK void E_EEPROM_XMC1_TEST_HOOK_ReadSingleBlock(uint32_t const address, uint32_t *const data)
{
}
__WEAK void E_EEPROM_XMC1_TEST_HOOK_WriteSinglePage(uint32_t const address, const uint32_t *const data)
{
}
__WEAK void E_EEPROM_XMC1_TEST_HOOK_EraseSinglePage(uint32_t const address)
{
}
__WEAK uint32_t E_EEPROM_XMC1_TEST_HOOK_ReadSingleWord(uint32_t const address)
{
    return (0U);
}
__WEAK uint32_t E_EEPROM_XMC1_TEST_HOOK_GetFlashStatus(void)
{
    return (0U);
}
#endif

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_Init
 ********************************************************************************
 * Summary:
 * Driver Module Initialization function. This service shall initialize the Flash
 * EEPROM Emulation module using the values provided by configuration set.
 *
 * Parameters:
 * handle_ptr
 *
 * Return:
 * E_EEPROM_XMC1_STATUS_t
 *
 *******************************************************************************/
E_EEPROM_XMC1_STATUS_t E_EEPROM_XMC1_Init(E_EEPROM_XMC1_t *const handle_ptr)
{
    uint32_t indx;
    uint32_t marker_state;

    e_eeprom_xmc1_handle = handle_ptr;

    XMC_ASSERT("E_EEPROM_XMC1_Write:Invalid Buffer Pointer", (handle_ptr != NULL));

    /* Check if the E_EEPROM_XMC1_Init API is called once*/
    if (handle_ptr->state != E_EEPROM_XMC1_STATUS_SUCCESS)
    {
#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
        handle_ptr->state = (E_EEPROM_XMC1_STATUS_t)CRC_SW_Init(handle_ptr->crc_handle_ptr);
        if (handle_ptr->state != E_EEPROM_XMC1_STATUS_SUCCESS)
        {
            handle_ptr->state = E_EEPROM_XMC1_STATUS_FAILURE;
        }
        else
#endif
        {
            /* Check max. block_count in configuration */
            if (handle_ptr-> block_count > E_EEPROM_XMC1_MAX_BLOCK_COUNT)
            {
               handle_ptr->state = E_EEPROM_XMC1_STATUS_FAILURE;
               return (handle_ptr->state);
            }
            /* Initialize the cache variables for the User defined Block configuration list */
            indx = 0U;
            do
            {
                E_EEPROM_XMC1_CACHE_t * block_ptr;

                if (E_EEPROM_XMC1_MAX_BLOCK_SIZE < handle_ptr->block_config_ptr[indx].size)
                {
                   handle_ptr->state = E_EEPROM_XMC1_STATUS_FAILURE;
                   return (handle_ptr->state);
                }

                block_ptr = &(handle_ptr->data_ptr->block_info[indx]);

                block_ptr->address = 0U;
                block_ptr->status.consistent = 0U;
                block_ptr->status.valid = 1U;
                block_ptr->status.copied = 0U;
                block_ptr->status.crc = 0U;
                indx++;
            } while (indx < handle_ptr->block_count);

            /********* Initialize all global variables *****************/
            handle_ptr->data_ptr->updated_cache_index = 0U;
            handle_ptr->data_ptr->cache_state = E_EEPROM_XMC1_CACHE_IDLE;
            handle_ptr->data_ptr->gc_state = E_EEPROM_XMC1_GC_UNINT;
            handle_ptr->data_ptr->init_gc_state = 0U;
            handle_ptr->data_ptr->gc_log_block_count = 0U;
            handle_ptr->data_ptr->crc_buffer = 0U;

            handle_ptr->data_ptr->written_block_counter = (uint32_t)0;
            handle_ptr->data_ptr->curr_bank_src_addr = 0U;
            handle_ptr->data_ptr->gc_src_addr = 0U;
            handle_ptr->data_ptr->gc_dest_addr = 0U;
            handle_ptr->data_ptr->next_free_block_addr = 0U;
            handle_ptr->data_ptr->gc_block_counter = (uint32_t)0;
            handle_ptr->data_ptr->user_write_bytes_count = 0U;

            handle_ptr->data_ptr->current_bank = 0U;

            XMC_FLASH_SetHardReadLevel(XMC_FLASH_HARDREAD_LEVEL_WRITTEN);

            /* Read the marker blocks from flash and decide the MARKER STATES */
            marker_state = E_EEPROM_XMC1_lReadMarkerBlocks();


            /*
             * Call INIT-GC state machine function to take decision on current MARKER STATE available.
             * Progress to GC state machine or PrepareDFLASH State machine after completing  the Cache update
             */
            E_EEPROM_XMC1_lInitGc(marker_state);

            /* If Initialization is done without any errors, set the INIT API called state into Initialized once */
            if (handle_ptr->data_ptr->gc_state == E_EEPROM_XMC1_GC_IDLE)
            {
                handle_ptr->state = E_EEPROM_XMC1_STATUS_SUCCESS;
            }
            else
            {
                handle_ptr->state = E_EEPROM_XMC1_STATUS_FAILURE;
            }
        }
    }
    return (handle_ptr->state);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_Write
 ********************************************************************************
 * Summary:
 * This function shall write user data block into flash
 *
 * Parameters:
 * block_number  - Number of logical block (Block-ID)
 * data_buffer_ptr - Pointer to user data buffer
 *
 * Return:
 * E_EEPROM_XMC1_OPERATION_STATUS_t
 *
 *******************************************************************************/
E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_Write(uint8_t block_number, uint8_t *data_buffer_ptr)
{
    E_EEPROM_XMC1_OPERATION_STATUS_t status;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    XMC_ASSERT("E_EEPROM_XMC1_Write:Wrong Block Number", (E_EEPROM_XMC1_lGetUsrBlockIndex(block_number) !=
            E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND));
    XMC_ASSERT("E_EEPROM_XMC1_Write:Invalid Buffer Pointer", (data_buffer_ptr != NULL));

    status = E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED;

    /* Execute only if there is no previous pending request and the GC process is in IDLE state */
    if (data_ptr->gc_state == E_EEPROM_XMC1_GC_IDLE)
    {
        /* Call local function to write the specified block of data into flash */
        status = (E_EEPROM_XMC1_OPERATION_STATUS_t)E_EEPROM_XMC1_lLocalWrite(block_number, data_buffer_ptr, 0U);
    }

    return((E_EEPROM_XMC1_OPERATION_STATUS_t)status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_InvalidateBlock
 ********************************************************************************
 * Summary:
 * This function shall invalidate user data block.
 *
 * Parameters:
 * block_number  - Number of logical block (Block-ID)
 *
 * Return:
 * E_EEPROM_XMC1_OPERATION_STATUS_t
 *
 *******************************************************************************/
E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_InvalidateBlock(uint8_t block_number)
{
    uint8_t* data_buffer_ptr;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_OPERATION_STATUS_t status;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);
    XMC_ASSERT("E_EEPROM_XMC1_InvalidateBlock:Wrong Block Number", (E_EEPROM_XMC1_lGetUsrBlockIndex(block_number) !=
            E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND));
    data_buffer_ptr =  data_ptr->read_write_buffer;
    status = E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED;

    /* Execute only if there is no previous pending request and the GC process is in IDLE state */
    if (data_ptr->gc_state == E_EEPROM_XMC1_GC_IDLE)
    {
        /* Call local function to write the specified block of data into flash */
        status = (E_EEPROM_XMC1_OPERATION_STATUS_t)E_EEPROM_XMC1_lLocalWrite( block_number, data_buffer_ptr ,1U);
    }

    return((E_EEPROM_XMC1_OPERATION_STATUS_t)status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_Read
 ********************************************************************************
 * Summary:
 * This function shall read user data blocks from flash.
 *
 * Parameters:
 * block_number  - Number of logical block
 * offset      - Start Location for Read start
 * data_buffer_ptr - Pointer to user data buffer
 * length      - End Location for read completion
 *
 * Return:
 * E_EEPROM_XMC1_OPERATION_STATUS_t
 *
 *******************************************************************************/
E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_Read(uint8_t block_number,
        uint32_t offset,
        uint8_t *data_buffer_ptr,
        uint32_t length)
{
    uint32_t block_size;
    uint32_t user_block_index;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_OPERATION_STATUS_t status;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);
    user_block_index = E_EEPROM_XMC1_lGetUsrBlockIndex(block_number);
    block_size = e_eeprom_xmc1_handle->block_config_ptr[user_block_index].size;

    XMC_ASSERT("E_EEPROM_XMC1_Read:Wrong Block Number", (user_block_index  != E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND));
    XMC_ASSERT("E_EEPROM_XMC1_Read:Invalid Buffer Pointer", (data_buffer_ptr != NULL));

    status = E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED;

    /*Execute only if GC process is in IDLE state */
    if ((data_ptr->gc_state == E_EEPROM_XMC1_GC_IDLE) && (((uint32_t)offset + length) <= block_size))
    {
        if (data_ptr->block_info[user_block_index].status.valid == 0U) /* If cache says Inconsistent */
        {
            status = E_EEPROM_XMC1_OPERATION_STATUS_INVALID_BLOCK;
        }
        else if (data_ptr->block_info[user_block_index].status.consistent == 0U) /* If cache says Invalid */
        {
            status = E_EEPROM_XMC1_OPERATION_STATUS_INCONSISTENT_BLOCK;
        }
        else
        {
            data_ptr->read_start_address = data_ptr->block_info[user_block_index].address;
            status = (E_EEPROM_XMC1_OPERATION_STATUS_t)E_EEPROM_XMC1_lReadBlockContents(data_buffer_ptr , length , offset);

            if ((uint32_t)status != 0U)
            {
                status = E_EEPROM_XMC1_OPERATION_STATUS_FAILURE;
            }
        }
    }
    return((E_EEPROM_XMC1_OPERATION_STATUS_t)status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_StartGarbageCollection
 ********************************************************************************
 * Summary:
 * This function shall start Garbage collection.
 *
 * Parameters:
 * void
 *
 * Return:
 * E_EEPROM_XMC1_OPERATION_STATUS_t
 *
 *******************************************************************************/
E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_StartGarbageCollection(void)
{
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_OPERATION_STATUS_t status;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    status = E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED;

    /* Check if the E_EEPROM_XMC1_Init API is called */
    if (data_ptr->gc_state == E_EEPROM_XMC1_GC_IDLE)
    {
        data_ptr->gc_state = E_EEPROM_XMC1_GC_REQUESTED;

        /* Call local function to start garbage collection process from scratch */
        E_EEPROM_XMC1_lGarbageCollection();

        if (data_ptr->gc_state == E_EEPROM_XMC1_GC_FAIL)
        {
            status = E_EEPROM_XMC1_OPERATION_STATUS_FAILURE;
        }
        else
        {
            status = E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS;
        }
    }

    return((E_EEPROM_XMC1_OPERATION_STATUS_t)status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_GetStatus
 ********************************************************************************
 * Summary:
 * This function shall return the status of the APP
 *
 * Parameters:
 * void
 *
 * Return:
 * E_EEPROM_XMC1_STATUS_t
 *
 *******************************************************************************/
E_EEPROM_XMC1_STATUS_t E_EEPROM_XMC1_GetStatus(void)
{
    E_EEPROM_XMC1_STATUS_t status;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* If the GC/InitGC has failed */
    if (data_ptr->gc_state == E_EEPROM_XMC1_GC_IDLE)
    {
        status = E_EEPROM_XMC1_STATUS_IDLE;
    }
    else if (data_ptr->gc_state == E_EEPROM_XMC1_GC_FAIL)
    {
        status = E_EEPROM_XMC1_STATUS_FAILURE;
    }
    else
    {
        status = E_EEPROM_XMC1_STATUS_BUSY;
    }

    return (status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_IsGarbageCollectionNeeded
 ********************************************************************************
 * Summary:
 * This function returns the whether the block can be fit inside the bank or it
 * needs a garbage collection to fit in
 *
 * Parameters:
 * block_number
 *
 * Return:
 * bool
 *
 *******************************************************************************/
bool E_EEPROM_XMC1_IsGarbageCollectionNeeded(uint8_t block_number)
{
    bool status;
    uint32_t flash_blocks;
    uint32_t user_block_index;
    uint32_t remaining_blocks;
    E_EEPROM_XMC1_BLOCK_t *block_ptr;

    status = false;
    user_block_index = E_EEPROM_XMC1_lGetUsrBlockIndex(block_number);
    block_ptr = e_eeprom_xmc1_handle->block_config_ptr + user_block_index;

    XMC_ASSERT("E_EEPROM_XMC1_IsGarbageCollectionNeeded:Wrong Block Number", (user_block_index  !=
            E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND));

    flash_blocks = E_EEPROM_XMC1_lGetDFLASHPhysicalBlocks(block_ptr->size);
    remaining_blocks = E_EEPROM_XMC1_lGetFreeDFLASHBlocks();

    if (remaining_blocks < flash_blocks)
    {
        status = true;
    }

    return (status);
}

#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_VerifyBlockCrcStatus
 ********************************************************************************
 * Summary:
 * It reads the complete data block from the flash and compare the CRC from header
 * block with the computed CRC using CRC_SW APP. Read from arbitrary location and
 * limited length is not possible under this API.
 *
 * Parameters:
 * block_number  - Number of logical block
 * data_buffer_ptr - Pointer to user data buffer
 *
 * Return:
 * E_EEPROM_XMC1_OPERATION_STATUS_t
 *
 *******************************************************************************/
E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_VerifyBlockCrcStatus(uint8_t block_number, uint8_t *data_buffer_ptr)
{
    uint32_t block_size;
    uint32_t user_block_index;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_OPERATION_STATUS_t status;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);
    user_block_index = (uint32_t)E_EEPROM_XMC1_lGetUsrBlockIndex( block_number);
    block_size = e_eeprom_xmc1_handle->block_config_ptr[user_block_index].size;

    XMC_ASSERT("E_EEPROM_XMC1_ReadBlockWithCRC:Wrong Block Number", (user_block_index  !=
            E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND));
    XMC_ASSERT("E_EEPROM_XMC1_ReadBlockWithCRC:Invalid Buffer Pointer", (data_buffer_ptr != NULL));

    status = E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED;

    /*Execute only if GC process is in IDLE state */
    if ((data_ptr->gc_state) == E_EEPROM_XMC1_GC_IDLE)
    {
        if (data_ptr->block_info[user_block_index].status.valid == 0U) /* If cache says Inconsistent */
        {
            status = E_EEPROM_XMC1_OPERATION_STATUS_INVALID_BLOCK;
        }
        else if (data_ptr->block_info[user_block_index].status.consistent == 0U) /* If cache says Invalid */
        {
            status = E_EEPROM_XMC1_OPERATION_STATUS_INCONSISTENT_BLOCK;
        }
        else
        {
            data_ptr->read_start_address = data_ptr->block_info[user_block_index].address ;
            /* Call local function to read the specified block of data from flash */
            status = (E_EEPROM_XMC1_OPERATION_STATUS_t)E_EEPROM_XMC1_lReadBlockContents(data_buffer_ptr,
                    block_size , 0U);

            if (status == E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS)
            {
                /* Call local function to cross check the CRC, No ECC check done again for the CRC read function  */
                status = (E_EEPROM_XMC1_OPERATION_STATUS_t)E_EEPROM_XMC1_lReadBlockCrcStatus(block_number, data_buffer_ptr,
                        block_size);
            }
            else
            {
                status = E_EEPROM_XMC1_OPERATION_STATUS_FAILURE;
            }
        }
    }
    return((E_EEPROM_XMC1_OPERATION_STATUS_t)status);
}
#endif

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_GetPreviousData
 ********************************************************************************
 * Summary:
 * This function shall read the just previous copy of the particular block when
 * requested. This function is used commonly when the latest copy gets corrupted.
 *
 * Parameters:
 * block_number   - Number of logical block
 * offset       - Start Location for Read start
 * data_buffer_ptr - Pointer to user data buffer
 * length       - End Location for read completion
 *
 * Return:
 * E_EEPROM_XMC1_STATUS_t
 *
 *******************************************************************************/
E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_GetPreviousData(uint8_t block_number,
        uint32_t offset,
        uint8_t *data_buffer_ptr,
        uint32_t length)
{
    uint32_t block_size;
    uint32_t read_start_addr;
    uint32_t user_block_index;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_OPERATION_STATUS_t status;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);
    user_block_index = E_EEPROM_XMC1_lGetUsrBlockIndex(block_number);
    block_size = e_eeprom_xmc1_handle->block_config_ptr[user_block_index].size;

    XMC_ASSERT("E_EEPROM_XMC1_GetPreviousData:Wrong Block Number", (user_block_index  !=
            E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND));
    XMC_ASSERT("E_EEPROM_XMC1_GetPreviousData:Invalid Buffer Pointer", (data_buffer_ptr != NULL));

    /*Execute only if GC process is in IDLE state */
    if ((data_ptr->gc_state == E_EEPROM_XMC1_GC_IDLE) && (((uint32_t)offset + length) <= block_size))
    {

        read_start_addr = E_EEPROM_XMC1_lGetPrevData(block_number);

        if (read_start_addr != 0U )
        {
            data_ptr->read_start_address =  read_start_addr;

            /* Call local function to read the specified block of data from flash */
            status = (E_EEPROM_XMC1_OPERATION_STATUS_t)E_EEPROM_XMC1_lReadBlockContents(data_buffer_ptr, length , offset);
            if ((uint32_t)status != 0U)
            {
                status = E_EEPROM_XMC1_OPERATION_STATUS_FAILURE;
            }
        }
        else
        {
            status = E_EEPROM_XMC1_OPERATION_STATUS_INCONSISTENT_BLOCK;
        }
    }
    else
    {
        status = E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED;
    }

    return((E_EEPROM_XMC1_OPERATION_STATUS_t)status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lGetPrevData
 ********************************************************************************
 * Summary:
 * This function will traverse through the bank and find the previous copy of
 * the block if existing.
 *
 * Parameters:
 * block_number  - User block number / ID
 *
 * Return:
 * uint32_t - Flash NVM_STATUS register value
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lGetPrevData(uint8_t block_number)
{
    uint32_t block_size;
    uint32_t block_index;
    uint32_t data_sec_start_addr;
    uint32_t expected_block_count;
    uint32_t block_read_start_addr;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* Get the block details */
    block_index = (uint32_t)E_EEPROM_XMC1_lGetUsrBlockIndex(block_number);
    block_size = e_eeprom_xmc1_handle->block_config_ptr[block_index].size;
    expected_block_count = E_EEPROM_XMC1_lGetDFLASHPhysicalBlocks(block_size);

    /* Find the data bank starting address from current Bank to decide when to stop reading of blocks*/
    if (data_ptr->current_bank == 0U)
    {
        data_sec_start_addr = E_EEPROM_XMC1_FLASH_BANK0_BASE + E_EEPROM_XMC1_DATA_BLOCK_OFFSET;
    }
    else
    {
        data_sec_start_addr = E_EEPROM_XMC1_FLASH_BANK1_BASE + E_EEPROM_XMC1_DATA_BLOCK_OFFSET;
    }

    block_read_start_addr = data_ptr->block_info[block_index].address;

    if (block_read_start_addr >= (data_sec_start_addr + E_EEPROM_XMC1_FLASH_BLOCK_SIZE))
    {
        block_read_start_addr = E_EEPROM_XMC1_lSearchBlockCopy(block_number,
                block_read_start_addr - E_EEPROM_XMC1_FLASH_BLOCK_SIZE,
                data_sec_start_addr);


        if ((block_read_start_addr < data_sec_start_addr) ||
                (data_ptr->block_result.status.consistent != 1U) ||
                (data_ptr->block_result.block_count != expected_block_count) ||
                (data_ptr->block_result.status.valid != 1U))
        {
            block_read_start_addr = 0U;  /* No Previous copy of block exist*/
        }
    }
    else
    {
        block_read_start_addr = 0U;  /* No Previous copy of block can exist*/
    }

    return (block_read_start_addr);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lSearchBlockCopy
 ********************************************************************************
 * Summary:
 * This function reads the block header bytes and compare the block number to
 * find the matching block
 *
 * Parameters:
 * block_number  - User block number / ID
 *
 * Return:
 * uint32_t - Flash NVM_STATUS register value
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lSearchBlockCopy(uint8_t required_block_number,
        uint32_t read_addr,
        uint32_t data_sec_start_addr)
{
    uint32_t header_word;
    uint32_t block_count;
    uint8_t block_status;
    uint8_t read_block_number;
    uint32_t block_start_address;
    uint32_t is_all_blocks_clean;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_BLOCK_HEADER_t* block_header_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    block_count = 0U;
    block_start_address = 0U;
    is_all_blocks_clean = 1U;
    data_ptr->block_result.status.consistent = 0U;
    data_ptr->block_result.status.valid = 0U;
    data_ptr->block_result.block_count = 0U;

    /* Loop until the first block address and check if any block number is matching the required block number*/
    while ((data_sec_start_addr <= read_addr) && (block_start_address == 0U))
    {
        /* Clear all error status flags before flash operation*/
        XMC_FLASH_ClearStatus();

        /* Read the header word */
        header_word = E_EEPROM_XMC1_lReadSingleWord(read_addr);

        block_header_ptr = (E_EEPROM_XMC1_BLOCK_HEADER_t*)(void *)(&header_word);
        read_block_number = block_header_ptr->block_number;
        block_status = block_header_ptr->status;

        /*Check whether the block number is matching the required block number*/
        if (read_block_number == required_block_number)
        {
            block_count++;

            /* Check if any ECC error in the header */
            if ( ( E_EEPROM_XMC1_lGetFlashStatus() & (uint32_t)XMC_FLASH_STATUS_ECC2_READ_ERROR ) != 0U )
            {
                is_all_blocks_clean = 0U;
            }
            /* Check if block header is of the starting block */
            if (block_status & E_EEPROM_XMC1_START_BIT)
            {
                if ( is_all_blocks_clean == 1U )
                {
                    data_ptr->block_result.status.consistent = 1U;
                }

                if (block_status & (uint8_t)E_EEPROM_XMC1_VALID_BIT)
                {
                    data_ptr->block_result.status.valid = 1U;
                }

                data_ptr->block_result.block_count = block_count;
                block_start_address = read_addr;
            }
            else
            {
                read_addr -= E_EEPROM_XMC1_FLASH_BLOCK_SIZE;
            }
        }
        else
        {
            read_addr -= E_EEPROM_XMC1_FLASH_BLOCK_SIZE;
        }
    }
    return(block_start_address);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lInitGc
 ********************************************************************************
 * Summary:
 * his function shall detect if there was any interruption in the ongoing running
 * state (Read/Write/GC). If yes, then this routine shall decide to run a state
 * machine to bring back the emulation to normal state.
 *
 * Parameters:
 * marker_dirty_state  - Dirty state
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lInitGc(const uint32_t marker_dirty_state)
{
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    if ( marker_dirty_state == E_EEPROM_XMC1_BOTH_BANKS_INVALID )  /* If both Bank state markers are in dirty state */
    {
        data_ptr->init_gc_state = E_EEPROM_XMC1_MB_DIRTY;
        E_EEPROM_XMC1_lInitllegalStateMachine();
    }
    else if ( marker_dirty_state == E_EEPROM_XMC1_BANK0_INVALID )  /* If Only Bank0 state marker is in dirty state */
    {
        data_ptr->init_gc_state &= E_EEPROM_XMC1_INIT_STATE_0F;
        data_ptr->init_gc_state |= E_EEPROM_XMC1_INIT_STATE_D0;
        E_EEPROM_XMC1_lInitDirtyStateMachine();
    }
    else if ( marker_dirty_state == E_EEPROM_XMC1_BANK1_INVALID )  /* If Only Bank1 state marker is in dirty state */
    {
        data_ptr->init_gc_state &= E_EEPROM_XMC1_INIT_STATE_F0;
        data_ptr->init_gc_state |= E_EEPROM_XMC1_INIT_STATE_0D;
        E_EEPROM_XMC1_lInitDirtyStateMachine();
    }
    else                                      /* If both Bank state markers have valid state */
    {
        E_EEPROM_XMC1_lInitNormalStateMachine();
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lInitllegalStateMachine
 ********************************************************************************
 * Summary:
 * This function shall erase all flash and start from fresh depending upon the
 * user configuration
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lInitllegalStateMachine(void)
{
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /*
     * Any state apart from the normal states is considered as Illegal state. Next operation = Start Prepare DFlash
     * (Only if the configuration option Erase all is 1U) IF Configuration Option is 0U, Next Operation = Fail State
     */
    if (e_eeprom_xmc1_handle->erase_all_auto_recovery == 1U)
    {
        /* Change the current Bank to Bank0 */
        data_ptr->current_bank = 0U;
        E_EEPROM_XMC1_lInitGcNormalStates( E_EEPROM_XMC1_PREPFLASH_FF, 1U);
    }
    else
    {
        data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lInitDirtyStateMachine
 ********************************************************************************
 * Summary:
 * This function shall address the dirty state recovery mechanism by erasing and
 * rewriting states
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lInitDirtyStateMachine(void)
{
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);
    switch (data_ptr->init_gc_state)
    {
    case E_EEPROM_XMC1_INIT_STATE_2D:
        /* Change the current Bank to Bank0 and recover from the dirty state to 2E  */
        data_ptr->current_bank = 0U;
        /* Transition states : 2D -> 2F -> 2E */
        E_EEPROM_XMC1_lErasedDirtyStateRecovery( E_EEPROM_XMC1_END_ERASE_OFFSET );
        break;
    case E_EEPROM_XMC1_INIT_STATE_D2:
        /* Change the current Bank to Bank1 and recover from the dirty state to E2 */
        data_ptr->current_bank = 1U;
        /* Transition states : D2 -> F2 -> E2 */
        E_EEPROM_XMC1_lErasedDirtyStateRecovery( E_EEPROM_XMC1_END_ERASE_OFFSET );
        break;
    case E_EEPROM_XMC1_INIT_STATE_AD:
        /* Change the current Bank to Bank0 and recover from the dirty state to 2E */
        data_ptr->current_bank = 0U;
        /* Transition states : AD -> A0 -> GC PROCESS -> 2E */
        E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery( E_EEPROM_XMC1_COPY_COMPLETED ,
                E_EEPROM_XMC1_GC_NEXT_BANK_VALID , 1U);
        break;
    case E_EEPROM_XMC1_INIT_STATE_DA:
        /* Change the current Bank to Bank1  and recover from the dirty state to E2*/
        data_ptr->current_bank = 1U;
        /* Transition states : DA -> 0A -> GC PROCESS -> E2 */
        E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery( E_EEPROM_XMC1_COPY_COMPLETED ,
                E_EEPROM_XMC1_GC_NEXT_BANK_VALID , 1U);
        break;
    case E_EEPROM_XMC1_INIT_STATE_0D:
        /* Change the current Bank to Bank1 and recover from the dirty state to E2 */
        data_ptr->current_bank = 1U;
        /* Transition states : 0D -> 02 -> GC PROCESS -> E2 */
        E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery( E_EEPROM_XMC1_VALID_STATE ,
                E_EEPROM_XMC1_GC_ERASE_PREV_BANK , 0U);
        break;
    case E_EEPROM_XMC1_INIT_STATE_D0:
        /* Change the current Bank to Bank0 and recover from the dirty state to 2E */
        data_ptr->current_bank = 0U;
        /* Transition states : D0 -> 20 -> GC PROCESS -> 2E */
        E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery( E_EEPROM_XMC1_VALID_STATE ,
                E_EEPROM_XMC1_GC_ERASE_PREV_BANK , 0U);
        break;
    default:
        /* Any state apart from the normal states is considered as Illegal state */
        /* Transition states : Illegal -> PREPARE DFLASH -> 2E */
        E_EEPROM_XMC1_lInitllegalStateMachine();
        break;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lInitNormalStateMachine
 ********************************************************************************
 * Summary:
 * Check which normal bank state machine process has executed.
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lInitNormalStateMachine(void)
{
    /* Check if the state matches with any of the normal marker states with active bank as bank-0*/
    if (E_EEPROM_XMC1_lInitBank0NormalStateMachine() == 0U)
    {
        /* Check if the state matches with any of the normal marker states with active bank as bank-1*/
        if (E_EEPROM_XMC1_lInitBank1NormalStateMachine() == 0U)
        {
            /* Check if the state matches with any other intermediate states from where a recover is possible  */
            if (E_EEPROM_XMC1_lInitOtherNormalStateMachine() == 0U)
            {
                /* If no matches found then go to illegal state and try to recover by erasing complete DFLASH */
                E_EEPROM_XMC1_lInitllegalStateMachine();
            }
        }
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lInitBank0NormalStateMachine
 ********************************************************************************
 * Summary:
 * Execute bank 0 state machine process and return the found states.
 *
 * Parameters:
 * void
 *
 * Return:
 * uint32_t : ( 1= state_found / 0 = State not found )
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lInitBank0NormalStateMachine(void)
{
    uint32_t state_found;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    state_found = 1U;

    switch (data_ptr->init_gc_state)
    {
    /*
     * Normal Data write in Bank-0 interrupted (2E), Next step = Cache Update and get ready to accept new request
     * Transition states : Nothing
     */
    case E_EEPROM_XMC1_INIT_NORMAL1:
        data_ptr->current_bank = 0U;
        E_EEPROM_XMC1_lInitGcNormalStates( E_EEPROM_XMC1_GC_IDLE, E_EEPROM_XMC1_EXECUTE_CACHE_UPDATE);
        break;

        /*
         * Data copy from Bank0 to Bank1 interrupted (2A), Next step = Erasing Bank-1 and restart copy from Bank-0
         * Transition states : (2A) -> ERASE_BANK0 (2F) -> 2E -> GC_PROCESS (2A -> 0A -> 20 -> F2 -> E2)
         */
    case E_EEPROM_XMC1_INIT_DATA_COPY1:
        data_ptr->current_bank = 0U;
        E_EEPROM_XMC1_lInitGcDataCopyState( E_EEPROM_XMC1_GC_REQUESTED, E_EEPROM_XMC1_END_ERASE_OFFSET);
        break;

        /*
         * Interrupted after copy completion from Bank1 to Bank0 (A0),Next step = Writing Valid state into Bank-0
         * Transition states : (A0) -> (20) -> GC_PROCESS (2F -> 2E)
         */
    case E_EEPROM_XMC1_INIT_COPY_DONE1:
        data_ptr->current_bank = 0U;
        E_EEPROM_XMC1_lInitGcNormalStates( E_EEPROM_XMC1_GC_NEXT_BANK_VALID, E_EEPROM_XMC1_EXECUTE_GC_STATE);
        break;

        /*
         * Interrupted after writing valid state to Bank0 (20), Next step = Erase of old redundant Bank-1 (2F)
         * Transition states : (20) -> (2F) -> GC_PROCESS (2E)
         */
    case E_EEPROM_XMC1_INIT_NEXT_VALID1:
        data_ptr->current_bank = 0U;
        E_EEPROM_XMC1_lInitGcNormalStates( E_EEPROM_XMC1_GC_ERASE_PREV_BANK, E_EEPROM_XMC1_EXECUTE_GC_STATE);
        break;

        /*
         * Interrupted after erase of old bank completed(2F), Next step = Mark erased Bank-1 with Formatted state(2E)
         * Transition states : (2F) -> GC_PROCESS (2E)
         */
    case E_EEPROM_XMC1_INIT_END_ERASE1:
        data_ptr->current_bank = 0U;
        E_EEPROM_XMC1_lInitGcNormalStates( E_EEPROM_XMC1_GC_MARK_END_ERASE1, E_EEPROM_XMC1_EXECUTE_GC_STATE);
        break;

    default:
        state_found = 0U;
        break;
    }
    return (state_found);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lInitBank1NormalStateMachine
 ********************************************************************************
 * Summary:
 * Execute bank 1 state machine process and return the found states.
 *
 * Parameters:
 * uint32_t : ( 1= state_found / 0 = State not found )
 *
 * Return:
 * E_EEPROM_XMC1_STATUS_t
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lInitBank1NormalStateMachine(void)
{
    uint32_t state_found;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    state_found = 1U;

    switch (data_ptr->init_gc_state)
    {
    /*
     * Normal Data write in Bank-1 interrupted (E2), Next step = Cache Update and get ready to accept new request
     * Transition states : Nothing
     */
    case E_EEPROM_XMC1_INIT_NORMAL2:
        data_ptr->current_bank = 1U;
        E_EEPROM_XMC1_lInitGcNormalStates( E_EEPROM_XMC1_GC_IDLE, E_EEPROM_XMC1_EXECUTE_CACHE_UPDATE);
        break;

        /*
         * Data copy from Bank1 to Bank0 interrupted (A2), Next step = Erasing Bank-0 and restart copy from Bank-1
         * Transition states : (A2) -> ERASE_BANK0 (F2) -> E2 -> GC_PROCESS (A2 -> A0 -> 20 -> 2F -> 2E)
         */
    case E_EEPROM_XMC1_INIT_DATA_COPY2:
        data_ptr->current_bank = 1U;
        E_EEPROM_XMC1_lInitGcDataCopyState( E_EEPROM_XMC1_GC_REQUESTED, E_EEPROM_XMC1_END_ERASE_OFFSET);
        break;

        /*
         * Interrupted after copy completion from Bank0 to Bank1 (0A),Next step = Writing Valid state into Bank-1
         * Transition states : (0A) -> (02) -> GC_PROCESS (F2 -> E2)
         */
    case E_EEPROM_XMC1_INIT_COPY_DONE2:
        data_ptr->current_bank = 1U;
        E_EEPROM_XMC1_lInitGcNormalStates( E_EEPROM_XMC1_GC_NEXT_BANK_VALID, E_EEPROM_XMC1_EXECUTE_GC_STATE);
        break;

        /*
         * Interrupted after writing valid state to Bank1 (02), Next step = Erase of old redundant Bank-0 (F2)
         * Transition states : (02) -> (F2) -> GC_PROCESS (E2)
         */
    case E_EEPROM_XMC1_INIT_NEXT_VALID2:
        data_ptr->current_bank = 1U;
        E_EEPROM_XMC1_lInitGcNormalStates( E_EEPROM_XMC1_GC_ERASE_PREV_BANK, E_EEPROM_XMC1_EXECUTE_GC_STATE);
        break;

        /*
         * Interrupted after erase of old bank completed(F2), Next step = Mark erased Bank-0 with Formatted state(E2)
         * Transition states : (F2) -> GC_PROCESS (E2)
         */
    case E_EEPROM_XMC1_INIT_END_ERASE2:
        data_ptr->current_bank = 1U;
        E_EEPROM_XMC1_lInitGcNormalStates( E_EEPROM_XMC1_GC_MARK_END_ERASE1, E_EEPROM_XMC1_EXECUTE_GC_STATE);
        break;

    default:
        state_found = 0U;
        break;
    }
    return (state_found);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lInitOtherNormalStateMachine
 ********************************************************************************
 * Summary:
 * Execute other state machine process and return the found states.
 *
 * Parameters:
 * void
 *
 * Return:
 * uint32_t : ( 1= state_found / 0 = State not found )
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lInitOtherNormalStateMachine(void)
{
    uint32_t state_found;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    state_found = 1U;

    switch (data_ptr->init_gc_state)
    {
    /* Interrupted after erase of both banks completed (FF), Next step = Start Prepare DFlash  */
    case E_EEPROM_XMC1_INIT_ALL_ERASED:
        /* Change the current Bank to Bank0 */
        data_ptr->current_bank = 0U;
        /* Transition states : FF ->  PREPARE_DFLASH (2F) -> 2E */
        E_EEPROM_XMC1_lInitGcNormalStates( E_EEPROM_XMC1_PREPFLASH_FF, E_EEPROM_XMC1_EXECUTE_PREP_FLASH);
        break;

        /*
         * Interrupted after erase of Bank1 during previous recovery(AF), Next step = Bank0 marker Page program (A0)
         * Transition states : AF -> A0 -> GC PROCESS -> 20 -> 2F -> 2E
         */
    case E_EEPROM_XMC1_INIT_STATE_AF:
        /* Change the current Bank to Bank1 */
        data_ptr->current_bank = 0U;

        E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery( E_EEPROM_XMC1_COPY_COMPLETED ,
                E_EEPROM_XMC1_GC_NEXT_BANK_VALID , 1U);
        break;

        /*
         * Interrupted after erase of Bank0 during previous recovery(FA), Next step = Bank1 marker Page program (0A)
         * Transition states : FA -> 0A -> GC PROCESS -> 02 -> F2 -> E2
         */
    case E_EEPROM_XMC1_INIT_STATE_FA:
        data_ptr->current_bank = 1U;
        E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery( E_EEPROM_XMC1_COPY_COMPLETED ,
                E_EEPROM_XMC1_GC_NEXT_BANK_VALID , 1U);
        break;

        /*
         * Interrupted after erase of Bank1 during previous recover(0F), Next step = Bank1 marker Page program (02)
         * Transition states : 0F -> 02 -> GC PROCESS -> F2 -> E2
         */
    case E_EEPROM_XMC1_INIT_STATE_0F:
        data_ptr->current_bank = 1U;
        E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery( E_EEPROM_XMC1_VALID_STATE ,
                E_EEPROM_XMC1_GC_ERASE_PREV_BANK , 0U);
        break;

        /*
         * Interrupted after erase of Bank1 during previous recover(F0), Next step = Bank1 marker Page program (20)
         * Transition states : F0 -> 20 -> GC PROCESS -> 2F -> 2E
         */
    case E_EEPROM_XMC1_INIT_STATE_F0:
        /* Change the current Bank to Bank0 */
        data_ptr->current_bank = 0U;
        /* Transition states : D0 -> 20 -> GC PROCESS -> 2E */
        E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery( E_EEPROM_XMC1_VALID_STATE ,
                E_EEPROM_XMC1_GC_ERASE_PREV_BANK , 0U);
        break;

    default:
        state_found = 0U;
        break;
    }
    return (state_found);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lInitGcNormalStates
 ********************************************************************************
 * Summary:
 * Executes normal Garbage collection state machine sub process
 *
 * Parameters:
 * current_state  - Current GC state
 * next_process  - Number of logical block
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lInitGcNormalStates(uint32_t current_state, uint32_t next_process)
{
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* Update the Bank related global variables */
    E_EEPROM_XMC1_lUpdateCurrBankInfo();

    if (next_process == E_EEPROM_XMC1_EXECUTE_PREP_FLASH)
    {
        /* Update the GC state*/
        data_ptr->gc_state = current_state;
        /* Start Prepare DFlash routine to build FEE base  */
        E_EEPROM_XMC1_lPrepareDFlash();
        /* Update the RAM Cache Table */
        E_EEPROM_XMC1_lUpdateCache();
    }
    else if (next_process == E_EEPROM_XMC1_EXECUTE_GC_STATE)
    {
        /* Update the GC state */
        data_ptr->gc_state = current_state;
        /* Update the RAM Cache Table */
        E_EEPROM_XMC1_lUpdateCache();
        /* Start Garbage Collection */
        E_EEPROM_XMC1_lGarbageCollection();
    }
    else /* if ( next_process == E_EEPROM_XMC1_EXECUTE_CACHE_UPDATE ) */
    {
        /* Update the RAM Cache Table */
        E_EEPROM_XMC1_lUpdateCache();
        /* Update the GC state as Bank-0 Erase Completed state */
        data_ptr->gc_state = current_state;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lInitGcDataCopyState
 ********************************************************************************
 * Summary:
 * Executes data copy state GC state machine sub process.
 *
 * Parameters:
 * current_state  - Current GC state
 * marker_offset  - Marker block offset
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lInitGcDataCopyState(uint32_t current_state, uint32_t marker_offset)
{
    uint32_t status;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* Update the Bank related global variables */
    E_EEPROM_XMC1_lUpdateCurrBankInfo();

    /* Update the GC state as restart copy process */
    data_ptr->gc_state = current_state ;

    /* Update the RAM Cache Table with */
    E_EEPROM_XMC1_lUpdateCache();

    /* Erase the previous redundant bank */
    status = E_EEPROM_XMC1_lEraseBank(data_ptr->prev_bank_end_addr);

    if (status == 0U)
    {
        E_EEPROM_XMC1_lSetMarkerBlockBuffer();

        /* Write formatted state to the erased bank (2E)  */
        status = E_EEPROM_XMC1_lGCWrite((uint32_t)(data_ptr->gc_dest_addr + marker_offset));

        if (status == 0U)
        {
            /* Start Garbage Collection */
            E_EEPROM_XMC1_lGarbageCollection();
        }
        else
        {
            data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
        }

    }
    else
    {
        data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
    }

}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lErasedDirtyStateRecovery
 ********************************************************************************
 * Summary:
 * Executes state machine sub process for erase dirty states to recover.
 *
 * Parameters:
 * marker_offset  - Marker block offset
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lErasedDirtyStateRecovery( uint32_t marker_offset)
{
    uint32_t  status;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* Update the Bank related global variables */
    E_EEPROM_XMC1_lUpdateCurrBankInfo();

    /* Erase the previous redundant bank */
    status = E_EEPROM_XMC1_lEraseBank(data_ptr->prev_bank_end_addr);

    if (status == 0U)
    {
        E_EEPROM_XMC1_lSetMarkerBlockBuffer();

        /* Write formatted state to the erased bank */
        status = E_EEPROM_XMC1_lGCWrite((uint32_t)(data_ptr->gc_dest_addr + marker_offset));
        if (status == 0U)
        {
            /* Update the RAM Cache Table with the written blocks of data.*/
            E_EEPROM_XMC1_lUpdateCache();

            data_ptr->gc_state = E_EEPROM_XMC1_GC_IDLE;
        }
        else
        {
            data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
        }
    }
    else
    {
        data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery
 ********************************************************************************
 * Summary:
 * Recovers from any copy process dirty state.
 *
 * Parameters:
 * current_state   - Current GC state
 * NextState      - Next GC state
 * page_addr_select - Page address from which bank to be written
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lCopyProcessDirtyStateRecovery( uint32_t current_state,
        uint32_t next_state,
        uint32_t page_addr_select)
{
    uint32_t  status;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* Update the Bank related global variables */
    E_EEPROM_XMC1_lUpdateCurrBankInfo();

    /* Set the marker blocks with copy completed state */
    E_EEPROM_XMC1_lSetMarkerPageBuffer(current_state);

    /* Clear all error status flags before flash operation*/
    XMC_FLASH_ClearStatus();

    /* Decide the bank from page_addr_select and Erase the marker page + Program with the current state + Verify */
    if (page_addr_select == 1U)
    {
        E_EEPROM_XMC1_lWriteSinglePage(data_ptr->gc_dest_addr, (uint32_t*)(void*)data_ptr->page_write_buffer);
    }
    else
    {
        E_EEPROM_XMC1_lWriteSinglePage(data_ptr->gc_src_addr, (uint32_t*)(void*)data_ptr->page_write_buffer);
    }

    status = E_EEPROM_XMC1_lGetFlashStatus();

    if (status == 0U)
    {
        /* Update the GC state as write next bank valid */
        data_ptr->gc_state = next_state ;
        /* Update the RAM Cache Table */
        E_EEPROM_XMC1_lUpdateCache();
        /* Start Garbage Collection */
        E_EEPROM_XMC1_lGarbageCollection();
    }
    else
    {
        data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lGarbageCollection
 ********************************************************************************
 * Summary:
 * This function execute's the garbage collection state machine.
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lGarbageCollection(void)
{
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    do
    {
        switch (data_ptr->gc_state)
        {
        case E_EEPROM_XMC1_GC_COPY_START:
            E_EEPROM_XMC1_lHandleGcStartCopy();
            break;

        case E_EEPROM_XMC1_GC_COPY_WRITE:
            E_EEPROM_XMC1_lHandleGcCopyWrite();
            break;

        case E_EEPROM_XMC1_GC_READ_NXTBLOCK:
            XMC_FLASH_ClearStatus();
            E_EEPROM_XMC1_lReadSingleBlock(data_ptr->gc_src_addr ,(uint32_t*)(void*)data_ptr->read_write_buffer);
            data_ptr->gc_state = E_EEPROM_XMC1_GC_COPY_WRITE;
            break;

        case E_EEPROM_XMC1_GC_COPY_END:
            E_EEPROM_XMC1_lHandleGcEndOfCopy();
            break;

        case E_EEPROM_XMC1_GC_NEXT_BANK_VALID:
            E_EEPROM_XMC1_lHandleGcOtherStates(E_EEPROM_XMC1_GC_NEXT_BANK_VALID, E_EEPROM_XMC1_GC_ERASE_PREV_BANK);
            break;

        case E_EEPROM_XMC1_GC_ERASE_PREV_BANK:
            E_EEPROM_XMC1_lHandleGcOtherStates( E_EEPROM_XMC1_GC_ERASE_PREV_BANK, E_EEPROM_XMC1_GC_MARK_END_ERASE1);
            break;

        case E_EEPROM_XMC1_GC_MARK_END_ERASE1:
            E_EEPROM_XMC1_lHandleGcOtherStates(E_EEPROM_XMC1_GC_MARK_END_ERASE1, E_EEPROM_XMC1_GC_IDLE);
            break;

        default:
            E_EEPROM_XMC1_lHandleGcRequested(); /* E_EEPROM_XMC1_GC_REQUESTED state*/
            break;
        }

    } while ((data_ptr->gc_state != E_EEPROM_XMC1_GC_IDLE) &&
            (data_ptr->gc_state != E_EEPROM_XMC1_GC_FAIL));
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lHandleGcRequested
 ********************************************************************************
 * Summary:
 * This function handles Garbage Collection GC REQUESTED state
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lHandleGcRequested(void)
{
    uint32_t status;
    uint32_t block_count;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_CACHE_t *cache_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    E_EEPROM_XMC1_lSetMarkerBlockBuffer();
    /* Write Copy start state to new bank  (2A) or (A2) */
    status = E_EEPROM_XMC1_lGCWrite((uint32_t)(data_ptr->gc_dest_addr + E_EEPROM_XMC1_BEGIN_OFFSET));
    if (status == 0U)
    {
        /* Initialize the copied status for all the logical blocks */
        cache_ptr = data_ptr->block_info;
        block_count = 0U;
        do
        {
            cache_ptr->status.copied = 0U;
            block_count++;
            cache_ptr++;
        } while (block_count != e_eeprom_xmc1_handle->block_count);

        data_ptr->gc_log_block_count = 0U;
        data_ptr->gc_state = E_EEPROM_XMC1_GC_COPY_START;
        data_ptr->gc_dest_addr = data_ptr->gc_dest_addr + E_EEPROM_XMC1_DATA_BLOCK_OFFSET;
    }
    else
    {
        data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lHandleGcStartCopy
 ********************************************************************************
 * Summary:
 * This function handles Garbage Collection GC START COPY state
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lHandleGcStartCopy(void)
{
    uint32_t state_flag;
    uint32_t block_count;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_CACHE_t *cache_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    state_flag = 0U;
    /* initialize the copied status for all the logical blocks */
    block_count = data_ptr->gc_log_block_count;
    cache_ptr = data_ptr->block_info + block_count;
    /*
     * Check all available blocks in cache table for Copy process. Condition breaks on either the current block is
     * consistent or all blocks check for consistency is finished
     */
    while ((state_flag == 0U) && (block_count != e_eeprom_xmc1_handle->block_count))
    {
        /* If block is consistent set state flag for copy enable*/
        if (((cache_ptr->address != 0U) && (cache_ptr->status.consistent == 1U)) && (cache_ptr->status.copied == 0U))
        {
            state_flag = 1U;
        }
        /* If block is inconsistent ignore the block from copy and try next block*/
        else
        {
            block_count++;
            cache_ptr++;
        }
    } /* end of while */

    /* If block is consistent */
    if (state_flag == 1U)
    {
        data_ptr->gc_src_addr = cache_ptr->address;
        data_ptr->gc_block_counter = 0U;

        /* Clear all error status flags before flash operation*/
        XMC_FLASH_ClearStatus();

        E_EEPROM_XMC1_lReadSingleBlock(data_ptr->gc_src_addr,(uint32_t*)(void*)data_ptr->read_write_buffer);

        /* Return value above is ignored as parameters passed from FEE are correct */
        data_ptr->gc_state = E_EEPROM_XMC1_GC_COPY_WRITE;
    }
    /* Finished copying all the logical blocks */
    else
    {
        /* Update the next free block pointer */
        data_ptr->next_free_block_addr = data_ptr->gc_dest_addr;
        data_ptr->gc_src_addr = data_ptr->curr_bank_src_addr;
        E_EEPROM_XMC1_lUpdateCurrBankInfo();
        data_ptr->gc_state = E_EEPROM_XMC1_GC_COPY_END;
    }
    data_ptr->gc_log_block_count = block_count;
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lHandleGcCopyWrite
 ********************************************************************************
 * Summary:
 * This function handles Garbage Collection GC START COPY WRITE state.
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lHandleGcCopyWrite(void)
{
    uint32_t size;
    uint32_t status;
    uint32_t block_count;
    uint32_t flash_physical_blocks;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_CACHE_t *cache_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* initialize the copied status for all the logical blocks */
    block_count = data_ptr->gc_log_block_count;
    cache_ptr = data_ptr->block_info + block_count;

    status = E_EEPROM_XMC1_lGCWrite((uint32_t)(data_ptr->gc_dest_addr));
    if (status == 0U)
    {
        (data_ptr->gc_block_counter)++;
        size = (e_eeprom_xmc1_handle->block_config_ptr[block_count].size);
        flash_physical_blocks = E_EEPROM_XMC1_lGetDFLASHPhysicalBlocks(size);
        /* If all the blocks of the logical block are copied */
        if ((data_ptr->gc_block_counter == flash_physical_blocks) || (cache_ptr->status.valid == 0U))
        {
            cache_ptr->status.copied = 1U;
            block_count++;
            data_ptr->gc_state = E_EEPROM_XMC1_GC_COPY_START;
            data_ptr->gc_dest_addr += E_EEPROM_XMC1_FLASH_BLOCK_SIZE;
            cache_ptr->address = data_ptr->gc_dest_addr - (E_EEPROM_XMC1_FLASH_BLOCK_SIZE * data_ptr->gc_block_counter);
        }
        else
        {
            data_ptr->gc_src_addr = data_ptr->gc_src_addr + E_EEPROM_XMC1_FLASH_BLOCK_SIZE;
            data_ptr->gc_dest_addr = data_ptr->gc_dest_addr + E_EEPROM_XMC1_FLASH_BLOCK_SIZE;
            data_ptr->gc_state = E_EEPROM_XMC1_GC_READ_NXTBLOCK;
        }
    }
    else
    {
        data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
    }
    data_ptr->gc_log_block_count = block_count;
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lHandleGcEndOfCopy
 ********************************************************************************
 * Summary:
 * This function handles Garbage Collection GC END OF COPY state
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lHandleGcEndOfCopy(void)
{
    uint32_t  status;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    E_EEPROM_XMC1_lSetMarkerBlockBuffer();
    /* Write Copy completed state to old bank (0A) or (A0) */
    status = E_EEPROM_XMC1_lGCWrite((uint32_t)(data_ptr->gc_src_addr + E_EEPROM_XMC1_END_OF_COPY_OFFSET));
    if (status == 0U)
    {
        /* Update the current bank to next bank */
        data_ptr->current_bank = data_ptr->current_bank ^ 1U;

        /* Update the Bank related global variables */
        E_EEPROM_XMC1_lUpdateCurrBankInfo();
        data_ptr->gc_state = E_EEPROM_XMC1_GC_NEXT_BANK_VALID;
    }
    else
    {
        data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lHandleGcOtherStates
 ********************************************************************************
 * Summary:
 * This function handles Garbage Collection GC NEXT BANk VALID, ERASE PREV BANK
 * and GC COMPLETED IDLE state
 *
 * Parameters:
 * current_state - current state machine status
 * next_state - next state of the state machine
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lHandleGcOtherStates( uint32_t current_state, uint32_t next_state)
{
    uint32_t  status;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    if (current_state == E_EEPROM_XMC1_GC_NEXT_BANK_VALID)
    {
        E_EEPROM_XMC1_lSetMarkerBlockBuffer();
        /* Write next bank to valid state  (02) or (20) */
        status = E_EEPROM_XMC1_lGCWrite((uint32_t)(data_ptr->gc_src_addr + E_EEPROM_XMC1_NEXT_VALID_OFFSET));
    }
    else if (current_state == E_EEPROM_XMC1_GC_ERASE_PREV_BANK)
    {
        /* Erase the previous redundant bank (F2) or (2F) */
        status = E_EEPROM_XMC1_lEraseBank(data_ptr->prev_bank_end_addr);
    }
    else
    {
        E_EEPROM_XMC1_lSetMarkerBlockBuffer();
        /* Write formatted state to the old erased bank (E2) or (2E) */
        status = E_EEPROM_XMC1_lGCWrite((uint32_t)(data_ptr->gc_dest_addr + E_EEPROM_XMC1_END_ERASE_OFFSET));
    }

    if (status == 0U)
    {
        data_ptr->gc_state = next_state;
    }
    else
    {
        data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lPrepareDFlash
 ********************************************************************************
 * Summary:
 * This function executes the prepare data flash to bring the state machine to
 * default state (2E).
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lPrepareDFlash(void)
{
    uint32_t status;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    do
    {
        switch (data_ptr->gc_state)
        {
        case E_EEPROM_XMC1_PREPFLASH_2F:

            /* Set the marker blocks with copy completed state */
            E_EEPROM_XMC1_lSetMarkerPageBuffer(E_EEPROM_XMC1_VALID_STATE);

            /* Clear all error status flags before flash operation*/
            XMC_FLASH_ClearStatus();

            E_EEPROM_XMC1_lWriteSinglePage(E_EEPROM_XMC1_FLASH_BANK0_BASE , (uint32_t*)(void*)data_ptr->page_write_buffer);

            status = E_EEPROM_XMC1_lGetFlashStatus();

            if (status == 0U)
            {
                data_ptr->gc_state = E_EEPROM_XMC1_PREPFLASH_2E;
            }
            else
            {
                data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
            }
            break;

        case E_EEPROM_XMC1_PREPFLASH_2E:

            E_EEPROM_XMC1_lSetMarkerBlockBuffer();

            /* Write Bank1 to formatted state  (2E) */
            status = E_EEPROM_XMC1_lGCWrite((uint32_t)E_EEPROM_XMC1_FLASH_BANK1_BASE + E_EEPROM_XMC1_END_ERASE_OFFSET);

            if (status == 0U)
            {
                data_ptr->gc_state = E_EEPROM_XMC1_GC_IDLE;
            }
            else
            {
                data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
            }
            break;

        default:  /* gc_state : E_EEPROM_XMC1_PREPFLASH_FF*/

            /* Erase the previous redundant bank */
            status = E_EEPROM_XMC1_lEraseBank(data_ptr->curr_bank_end_addr);

            /* Erase the previous redundant bank */
            if (status == 0U)
            {
                status = E_EEPROM_XMC1_lEraseBank(data_ptr->prev_bank_end_addr);

                if (status == 0U)
                {
                    data_ptr->gc_state = E_EEPROM_XMC1_PREPFLASH_2F;
                }
                else
                {
                    data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
                }
            }
            else
            {
                data_ptr->gc_state = E_EEPROM_XMC1_GC_FAIL;
            }
            break;
        }
    } while ((data_ptr->gc_state != E_EEPROM_XMC1_GC_IDLE) &&
            (data_ptr->gc_state != E_EEPROM_XMC1_GC_FAIL));
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lUpdateCache
 ********************************************************************************
 * Summary:
 * This utility function update's the cache table which contains the latest
 * information about the FLASH contents.
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lUpdateCache(void)
{
    uint32_t end_addr;
    uint32_t read_status;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_CACHE_t *cache_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* Evaluate the end address of the bank to start reading blocks for cache update */
    if (data_ptr->current_bank == 0U)
    {
        end_addr = E_EEPROM_XMC1_FLASH_BANK0_BASE + E_EEPROM_XMC1_DATA_BLOCK_OFFSET;
    }
    else
    {
        end_addr = E_EEPROM_XMC1_FLASH_BANK1_BASE + E_EEPROM_XMC1_DATA_BLOCK_OFFSET;
    }

    /* Reset the read number of blocks count variable and reset cache update index */
    data_ptr->written_block_counter = 0U;
    data_ptr->updated_cache_index = E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND;

    /* Start the Cache Update state machine */
    data_ptr->cache_state = E_EEPROM_XMC1_CACHE_EMPTY_BLOCK;

    /* Point to starting address of last data block of the bank */
    data_ptr->curr_bank_src_addr += ( E_EEPROM_XMC1_FLASH_BANK_SIZE - E_EEPROM_XMC1_FLASH_BLOCK_SIZE);
    /* Search for the first entry of a non empty block inside the valid bank starting from bottom */
    do{
        read_status = E_EEPROM_XMC1_lCacheEmptyBlkEval(end_addr);
    } while (data_ptr->cache_state == E_EEPROM_XMC1_CACHE_EMPTY_BLOCK);

    /* Update the next free block location only if it is not done by the previous function call  */
    if (data_ptr->next_free_block_addr == 0U)
    {
        data_ptr->next_free_block_addr = (data_ptr->curr_bank_src_addr) + E_EEPROM_XMC1_FLASH_BLOCK_SIZE;
    }

    /* Execute the Cache update state machine until the Start address of bank is reached traversing from end of bank */
    while (data_ptr->cache_state != E_EEPROM_XMC1_CACHE_UPDATE_DONE)
    {
        /* Check If the previous read had an ECC error or not */
        if (!(read_status & (uint32_t)XMC_FLASH_STATUS_ECC2_READ_ERROR))
        {
            /* Evaluate the Block status since no error found */
            E_EEPROM_XMC1_lEvalBlockStatus();
        }
        else
        {
            /* If previous read block of the block had correct block number then mark the block as inconsistent */
            if ( data_ptr->updated_cache_index != E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND )
            {
                /* Goto the cache table entry for the given block */
                cache_ptr = data_ptr->block_info;
                cache_ptr = cache_ptr + data_ptr->updated_cache_index;
                /* Since CacheUpdateIndex contains valid block the  previous read block must belong to this block */
                cache_ptr->address = E_EEPROM_XMC1_ALL_ONES;
            }
            /* Prepare for the next block */
            data_ptr->updated_cache_index = E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND;
            data_ptr->written_block_counter = 0U;
        }
        /* Check if all blocks have been read */
        if ( data_ptr->curr_bank_src_addr == end_addr )
        {
            /* Goto the next state */
            data_ptr->cache_state = E_EEPROM_XMC1_CACHE_UPDATE_DONE;
        }
        else
        {
            read_status = E_EEPROM_XMC1_lUpdateCacheBlockRead();
        }
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lCacheEmptyBlkEval
 ********************************************************************************
 * Summary:
 * This utility function  will search through the FLASH from the bottom of the
 * bank until a readable data block is found.
 *
 * Parameters:
 * end_addr - Last address to stop reading the block data
 *
 * Return:
 * uint32_t
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lCacheEmptyBlkEval(uint32_t end_addr)
{
    uint32_t status;
    uint32_t *read_word_ptr;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    XMC_FLASH_ClearStatus();

    /* Read the complete block */
    E_EEPROM_XMC1_lReadSingleBlock(data_ptr->curr_bank_src_addr, (uint32_t*)(void*)data_ptr->read_write_buffer);

    status = E_EEPROM_XMC1_lGetFlashStatus();

    /* If ECC error exists because of any previous interruptions or power failures during Flash operation in progress*/
    if (status & (uint32_t)XMC_FLASH_STATUS_ECC2_READ_ERROR)
    {
        /* Update the free block location of the valid bank once and for ever until new write happens*/
        if (data_ptr->next_free_block_addr == 0U)
        {
            data_ptr->next_free_block_addr = (data_ptr->curr_bank_src_addr + E_EEPROM_XMC1_FLASH_BLOCK_SIZE );
        }

        /* Check if all blocks have been read? If yes go to cache update complete state else move to the next block */
        if ( data_ptr->curr_bank_src_addr == end_addr )
        {
            data_ptr->cache_state = E_EEPROM_XMC1_CACHE_UPDATE_DONE;
        }
        else
        {
            data_ptr->curr_bank_src_addr -= E_EEPROM_XMC1_FLASH_BLOCK_SIZE;
        }
    }
    /* No ECC Error */
    else
    {
        read_word_ptr = ((uint32_t*)(void*)data_ptr->read_write_buffer);
        /* Check if the first word of the block is having some data written on it */
        if (*read_word_ptr != E_EEPROM_XMC1_ALL_ONES)
        {
            /* Increment the data block count and go to the next block read state */
            data_ptr->written_block_counter = data_ptr->written_block_counter + 1U;
            data_ptr->cache_state = E_EEPROM_XMC1_CACHE_NEXT_BLK;
        }
        else
        {
            /* Check if all blocks have been read? If yes go to cache update complete state else move to next block */
            if ( data_ptr->curr_bank_src_addr == end_addr )
            {
                data_ptr->cache_state = E_EEPROM_XMC1_CACHE_UPDATE_DONE;
            }
            data_ptr->curr_bank_src_addr -= E_EEPROM_XMC1_FLASH_BLOCK_SIZE;
        }
    }
    return (status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lEvalBlockStatus
 ********************************************************************************
 * Summary:
 * This function evaluates the block status and updates the cache (if required).
 *                    Entry Criteria:
 *                    1) No ECC error
 *                    2) Block number is non zero
 *                    Possible results:
 *                    1) cache updated: consistent
 *                    2) cache updated: inconsistent
 *                    3) cache already updated (no actions done)
 *                    4) cannot evaluate - requires more blocks to be read
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lEvalBlockStatus(void)
{
    uint32_t size;
    uint32_t indx;
    uint32_t status_byte;
    uint8_t  block_number;
    uint32_t physical_blocks;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_CACHE_t *cache_ptr;
    E_EEPROM_XMC1_BLOCK_HEADER_t *Ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);
    Ptr = (E_EEPROM_XMC1_BLOCK_HEADER_t *)(void *)data_ptr->read_write_buffer;
    block_number = Ptr->block_number;
    status_byte = Ptr->status;

    cache_ptr = data_ptr->block_info;

    /* Get the Index of the read block from the user configuration */
    indx = E_EEPROM_XMC1_lGetUsrBlockIndex(block_number);

    /* If the block is found */
    if ( (indx != E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND) )
    {
        /* Point to the cache table entry for the block to be evaluated */
        cache_ptr = cache_ptr + indx;

        /* Store Index of current block */
        data_ptr->updated_cache_index = indx;

        /* Check if cache table is updated for the given block : address = 0U => cache table not yet updated */
        if (cache_ptr->address == 0U)
        {
            /* If the starting block of the block found */
            if ((status_byte & E_EEPROM_XMC1_START_BIT ) != 0U)
            {
                /* Update the cache with block address */
                cache_ptr->address = data_ptr->curr_bank_src_addr;

                /* if the Valid bit for the logical block is set */
                if ((status_byte & (E_EEPROM_XMC1_VALID_BIT) ) != 0U)
                {
                    cache_ptr->status.valid = 1U;

                    /* if the CRC bit for the logical block is set */
                    if ((status_byte & (E_EEPROM_XMC1_CRC_BIT) ) != 0U)
                    {
                        cache_ptr->status.crc = 1U;
                    }
                    else
                    {
                        cache_ptr->status.crc = 0U;
                    }
                }
                else
                {
                    cache_ptr->status.valid = 0U;
                }

                /* Check If number of Flash blocks used for this data block is same in size */
                size = (uint32_t)(e_eeprom_xmc1_handle->block_config_ptr[indx].size);
                physical_blocks = E_EEPROM_XMC1_lGetDFLASHPhysicalBlocks(size);

                if ( data_ptr->written_block_counter == physical_blocks)
                {
                    cache_ptr->status.consistent = 1U;  /* EVALUATION RESULT : BLOCK CONSISTENT*/
                }
                else
                {
                    if (cache_ptr->status.valid == 1U)
                    {
                        cache_ptr->status.consistent = 0U;  /* EVALUATION RESULT : BLOCK INCONSISTENT */
                    }
                    else
                    {
                        cache_ptr->status.consistent = 1U; /* If the block is invalid, then mark : BLOCK INCONSISTENT */
                    }
                }
                /* Initialize the Index, block block count for the next read */
                data_ptr->updated_cache_index = E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND;
                data_ptr->written_block_counter = 0U;
            }

        }
        else
        {
            /*
             * EVALUATION RESULT : CACHE ALREADY UPDATED
             * If cache table is already updated for the block, no need to evaluate the block
             */
            data_ptr->updated_cache_index = E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND;
            data_ptr->written_block_counter = 0U;
        }
    }
    else
    {
        data_ptr->updated_cache_index = E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND;
        data_ptr->written_block_counter = 0U;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lUpdateCacheBlockRead
 ********************************************************************************
 * Summary:
 * Utility function to read data block from flash for cache update function.
 *
 * Parameters:
 * void
 *
 * Return:
 * uint32_t
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lUpdateCacheBlockRead(void)
{
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* Set the Write Source pointer to the next block */
    data_ptr->curr_bank_src_addr = data_ptr->curr_bank_src_addr -  E_EEPROM_XMC1_FLASH_BLOCK_SIZE;

    /* Clear all error status flags before flash operation*/
    XMC_FLASH_ClearStatus();

    E_EEPROM_XMC1_lReadSingleBlock(data_ptr->curr_bank_src_addr,  (uint32_t*)(void*)data_ptr->read_write_buffer);

    /* Increment number of read block counter  */
    data_ptr->written_block_counter = data_ptr->written_block_counter + 1U;

    return (E_EEPROM_XMC1_lGetFlashStatus());
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lGetUsrBlockIndex
 ********************************************************************************
 * Summary:
 * This utility function will return the Index (location) of the block in the
 * user configuration.
 *
 * Parameters:
 * block_number  - User data block number / ID
 *
 * Return:
 * uint32_t : returns array index pointer of block configuration
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lGetUsrBlockIndex(uint8_t block_number)
{
    uint32_t indx;
    E_EEPROM_XMC1_BLOCK_t  *block_ptr;

    indx = 0U;
    block_ptr = &(e_eeprom_xmc1_handle->block_config_ptr[indx]);

    /* Check for max configured block count reached and block number is matched against the configured block numbers */
    while ( (indx < e_eeprom_xmc1_handle->block_count) && (block_ptr->block_number != block_number) )
    {
        indx++;
        block_ptr++;
    }

    if ( indx == e_eeprom_xmc1_handle->block_count )
    {
        indx = E_EEPROM_XMC1_LOG_BLOCK_NOT_FOUND;
    }
    return (indx);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lGetDFLASHPhysicalBlocks
 ********************************************************************************
 * Summary:
 * Calculates and return the number of FLASH blocks required for a user data
 * block size.
 *
 * Parameters:
 * size - size of user data block
 *
 * Return:
 * uint32_t - returns maximum physical flash blocks required to store the data.
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lGetDFLASHPhysicalBlocks(uint32_t size)
{
    uint32_t physical_blocks;

    physical_blocks = 1U;
    /* If size is greater than the  */
    if ( size > E_EEPROM_XMC1_BLOCK1_DATA_SIZE )
    {
        size = size - E_EEPROM_XMC1_BLOCK1_DATA_SIZE;
        physical_blocks++;

        while (size > E_EEPROM_XMC1_BLOCK2_DATA_SIZE)
        {
            physical_blocks++;
            size = size - E_EEPROM_XMC1_BLOCK2_DATA_SIZE;
        }
    }
    return(physical_blocks);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lGetFreeDFLASHBlocks
 ********************************************************************************
 * Summary:
 * This routine will calculate the number of empty DFLASH blocks remaining in the bank.
 *
 * Parameters:
 * void
 *
 * Return:
 * uint32_t : Number of physical blocks left in the bank for writing data.
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lGetFreeDFLASHBlocks(void)
{
    uint32_t base_addr;
    uint32_t free_blocks;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    if (data_ptr->current_bank == 0U)
    {
        base_addr = E_EEPROM_XMC1_FLASH_BANK0_BASE;
    }
    else
    {
        base_addr = E_EEPROM_XMC1_FLASH_BANK1_BASE;
    }
    free_blocks = (uint32_t)( ( (base_addr + E_EEPROM_XMC1_FLASH_BANK_SIZE) - (data_ptr->next_free_block_addr)  )
            /  E_EEPROM_XMC1_FLASH_BLOCK_SIZE );
    return (free_blocks);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lUpdateCurrBankInfo
 ********************************************************************************
 * Summary:
 * Updates global addresses to keep track of writing and reading operations
 * respectively.
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lUpdateCurrBankInfo(void)
{
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    if (data_ptr->current_bank == 0U)
    {
        data_ptr->curr_bank_src_addr = E_EEPROM_XMC1_FLASH_BANK0_BASE;
        data_ptr->gc_src_addr = E_EEPROM_XMC1_FLASH_BANK0_BASE;
        data_ptr->gc_dest_addr = E_EEPROM_XMC1_FLASH_BANK1_BASE;
        data_ptr->curr_bank_end_addr = E_EEPROM_XMC1_FLASH_BANK0_END;
        data_ptr->prev_bank_end_addr = E_EEPROM_XMC1_FLASH_BANK1_END;
    }
    else
    {
        data_ptr->curr_bank_src_addr = E_EEPROM_XMC1_FLASH_BANK1_BASE;
        data_ptr->gc_src_addr = E_EEPROM_XMC1_FLASH_BANK1_BASE;
        data_ptr->gc_dest_addr = E_EEPROM_XMC1_FLASH_BANK0_BASE;
        data_ptr->curr_bank_end_addr = E_EEPROM_XMC1_FLASH_BANK1_END;
        data_ptr->prev_bank_end_addr = E_EEPROM_XMC1_FLASH_BANK0_END;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lReadMarkerBlocks
 ********************************************************************************
 * Summary:
 * This function will read the Block marker contents
 *
 * Parameters:
 * void
 *
 * Return:
 * uint32_t : marker_dirty_state
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lReadMarkerBlocks(void)
{
    uint32_t indx;
    uint32_t bank;
    uint32_t block;
    uint32_t temp_bank_state;
    uint32_t state_marker_cnt;
    uint32_t temp_state_marker;
    uint32_t marker_dirty_state;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* Initialize Local variables */
    temp_bank_state = 0U;
    marker_dirty_state = 0U;
    state_marker_cnt = 0U;
    do
    {
        /* Prepare the variables for state block update */
        temp_bank_state = (uint32_t)((uint32_t)temp_bank_state << (uint32_t)1U);

        bank  = (uint32_t)state_marker_cnt >> E_EEPROM_XMC1_TWO_BIT_POS;
        block = (uint32_t)state_marker_cnt - ((uint32_t)bank << E_EEPROM_XMC1_TWO_BIT_POS);

        /* Read the state block of bank*/
        temp_state_marker = E_EEPROM_XMC1_lReadVerifyMarker(bank , block);

        if (temp_state_marker == E_EEPROM_XMC1_ALL_ONES)
        {
            temp_bank_state |= 1U;
        }
        else if (temp_state_marker == E_EEPROM_XMC1_ALL_ZEROS)
        {
            temp_bank_state |= 0U;
        }
        else
        {
            indx = (uint32_t)((uint32_t)state_marker_cnt >> E_EEPROM_XMC1_TWO_BIT_POS);
            marker_dirty_state |= (uint32_t)((uint32_t)1U << (uint32_t)indx);
        }
        /* Update the counter "StateBlockCnt" */
        state_marker_cnt++;
    } while (state_marker_cnt < E_EEPROM_XMC1_EIGHT_BYTES);

    /* Update Global variables */
    data_ptr->init_gc_state = temp_bank_state;

    return (marker_dirty_state);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lReadVerifyMarker
 ********************************************************************************
 * Summary:
 * This function will verify the marker contents read out from state page.
 *
 * Parameters:
 * Bank  - Bank Number ( 0 / 1 )
 * Block - Block position
 *
 * Return:
 * uint32_t : E_EEPROM_XMC1_ALL_ONES
 * E_EEPROM_XMC1_ALL_ZEROS
 * E_EEPROM_XMC1_MB_DIRTY
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lReadVerifyMarker(uint32_t bank, uint32_t block)
{
    uint32_t indx;
    uint32_t return_val;
    uint32_t ones_counter;
    uint32_t zeros_counter;
    uint32_t marker_block_addr;
    uint32_t *marker_array_ptr;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    ones_counter = 0U;
    zeros_counter = 0U;
    marker_array_ptr = (uint32_t*)(void*)data_ptr->read_write_buffer;

    /* Calculate the Marker Block address from bank and Block size*/
    marker_block_addr = (E_EEPROM_XMC1_FLASH_BANK0_BASE +
            ((uint32_t)bank  * (uint32_t)E_EEPROM_XMC1_FLASH_BANK_SIZE)) +
                    ((uint32_t)block * (uint32_t)E_EEPROM_XMC1_FLASH_BLOCK_SIZE);

    /* Clear all error status flags before flash operation*/
    XMC_FLASH_ClearStatus();

    /* Read one complete block of data (4 Words = 128 bit) from the targeted Marker Block */
    E_EEPROM_XMC1_lReadSingleBlock(marker_block_addr, (uint32_t*)(void*)marker_array_ptr);

    /* Check for any flash hardware errors*/
    if (E_EEPROM_XMC1_lGetFlashStatus())
    {
        /* Any Hardware errors will result in Dirty state*/
        return_val = E_EEPROM_XMC1_MB_DIRTY;
    }
    else
    {
        for (indx = 0U ; indx <E_EEPROM_XMC1_MAX_WORDS_IN_BLOCK ; indx++)
        {
            /* Check for the Marker field and verify Marker either 0 or 1*/
            if (*(marker_array_ptr + indx) == E_EEPROM_XMC1_ALL_ZEROS)
            {
                zeros_counter++;
            }

            if (*(marker_array_ptr + indx) == E_EEPROM_XMC1_ALL_ONES)
            {
                ones_counter++;
            }
        }
        if (ones_counter == E_EEPROM_XMC1_FOUR_BYTES)
        {
            return_val = E_EEPROM_XMC1_ALL_ONES;
        }
        else if (zeros_counter == E_EEPROM_XMC1_FOUR_BYTES)
        {
            return_val = E_EEPROM_XMC1_ALL_ZEROS;
        }
        else
        {
            return_val = E_EEPROM_XMC1_MB_DIRTY;
        }
    }
    return (return_val);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lSetMarkerBlockBuffer
 ********************************************************************************
 * Summary:
 * This function will update the write buffer for a particular bank marker state
 *
 * Parameters:
 * void
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lSetMarkerBlockBuffer(void)
{
    uint32_t *array_ptr;
    uint32_t indx;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    array_ptr = (uint32_t*)(void*)data_ptr->read_write_buffer;
    for (indx = 0U ; indx < E_EEPROM_XMC1_FOUR_BYTES; indx++)
    {
        array_ptr[indx] = E_EEPROM_XMC1_ALL_ZEROS;
    }

}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lSetMarkerPageBuffer
 ********************************************************************************
 * Summary:
 * Fill complete Marker PAGE as per the below defined format.
 *
 *                          WORD - 0      WORD - 1      WORD - 2     WORD - 3
 *
 *             BLOCK0 -  (ZEROS/ONES)  (ZEROS/ONES)   (ZEROS/ONES)   (ZEROS/ONES)
 *             BLOCK1 -  (ZEROS/ONES)  (ZEROS/ONES)   (ZEROS/ONES)   (ZEROS/ONES)
 *             BLOCK2 -  (ZEROS/ONES)  (ZEROS/ONES)   (ZEROS/ONES)   (ZEROS/ONES)
 *             BLOCK3 -  (ZEROS/ONES)  (ZEROS/ONES)   (ZEROS/ONES)   (ZEROS/ONES)
 *             BLOCK4 -  (0xFFFFFFFF)  (0xFFFFFFFF)   (0xFFFFFFFF)   (0xFFFFFFFF)
 *             BLOCK5 -  (0xFFFFFFFF)  (0xFFFFFFFF)   (0xFFFFFFFF)   (0xFFFFFFFF)
 *           ----------------------------------------------------------------------
 *           ----------------------------------------------------------------------
 *             BLOCK16-  (0xFFFFFFFF)  (0xFFFFFFFF)   (0xFFFFFFFF)   (0xFFFFFFFF)
 *
 * Parameters:
 * State - Marker State
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lSetMarkerPageBuffer(uint32_t state)
{
    uint32_t indx;
    uint32_t bit_mask;
    uint32_t word_data;
    uint32_t *array_ptr;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    array_ptr = (uint32_t*)(void*)data_ptr->page_write_buffer;
    /*
     * Depending upon the state received check the bit positions where a state marker has to be updated to
     * get the actual state. Fill the first four blocks of the page with the state marker information.
     */

    /* Fill the first rest 4 blocks of the page with marker data  */
    for (bit_mask = 0U;bit_mask < E_EEPROM_XMC1_MARKER_MAX_SHIFT;bit_mask++)
    {
        if ( (state & (E_EEPROM_XMC1_MARKER_POSITION >> bit_mask )) == 0U )
        {
            word_data = E_EEPROM_XMC1_ALL_ZEROS;
        }
        else
        {
            word_data = E_EEPROM_XMC1_ALL_ONES;
        }
        for ( indx = 0U; indx< E_EEPROM_XMC1_MAX_WORDS_IN_BLOCK ; indx++ )
        {
            *array_ptr = word_data;
            array_ptr++;
        }

    }
    /* Fill the first rest 12 blocks of the page with all ones*/
    for (indx = 0U; indx < E_EEPROM_XMC1_PAGE1_EXTRA_WORDS; indx++)
    {
        *array_ptr = E_EEPROM_XMC1_ALL_ONES;
        array_ptr++;
    }

}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lEraseBank
 ********************************************************************************
 * Summary:
 * Erases the particular bank
 *
 * Parameters:
 * page_address - Bank end address
 *
 * Return:
 * uint32_t - Flash NVM_STATUS register value
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lEraseBank(uint32_t page_address)
{
    uint32_t indx;
    uint32_t status;
    /* Clear all error status flags before flash operation*/
    page_address = ((page_address) - E_EEPROM_XMC1_FLASH_PAGE_SIZE );
    page_address += 1U;
    indx = 0U;

    do
    {
        /* Clear all error status flags before flash operation*/
        XMC_FLASH_ClearStatus();

        E_EEPROM_XMC1_lEraseSinglePage(page_address);

        status = E_EEPROM_XMC1_lGetFlashStatus();

        page_address = page_address - (E_EEPROM_XMC1_FLASH_PAGE_SIZE );
        indx++;
    } while ((indx <E_EEPROM_XMC1_BANK_PAGES) && (status == 0U));

    return (status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lGCWrite
 ********************************************************************************
 * Summary:
 * Local function to write data into specified location during GC operation
 *
 * Parameters:
 * block_address  - flash address
 *
 * Return:
 * uint32_t - Flash NVM_STATUS register value
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lGCWrite(uint32_t block_address)
{
    uint32_t status;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    /* Clear all error status flags before flash operation*/
    XMC_FLASH_ClearStatus();

    /* Write a single block into flash*/
    E_EEPROM_XMC1_lWriteSingleBlock(block_address, (uint32_t*)(void*)data_ptr->read_write_buffer);
    status = E_EEPROM_XMC1_lGetFlashStatus();
    return (status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lLocalWrite
 ********************************************************************************
 * Summary:
 * Common local write function to do write block function or invalidate block.
 *
 * Parameters:
 * block_number   - User block number / ID
 * data_buffer_ptr - Data buffer address
 * invalidate    - (0 = normal write / 1 = invalidate block)
 *
 * Return:
 * uint32_t - Flash NVM_STATUS register value
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lLocalWrite( uint8_t block_number,
        uint8_t* data_buffer_ptr,
        uint32_t invalidate)
{
    uint32_t status;
    uint32_t flash_blocks;
    uint32_t perform_write;
    uint32_t user_block_index;
    uint32_t remaining_blocks;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_BLOCK_t *block_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    status = 0U;
    perform_write = 0U;
    user_block_index = E_EEPROM_XMC1_lGetUsrBlockIndex(block_number);
    block_ptr = e_eeprom_xmc1_handle->block_config_ptr + user_block_index;

    flash_blocks = E_EEPROM_XMC1_lGetDFLASHPhysicalBlocks(block_ptr->size);
    remaining_blocks = E_EEPROM_XMC1_lGetFreeDFLASHBlocks();

    if (remaining_blocks < flash_blocks)
    {
        /* Doesn't do Garbage collection if, GUI option garbage collection is disabled*/
        if (e_eeprom_xmc1_handle->garbage_collection == 1U)
        {
            /* Request for Garbage Collection and continue */
            data_ptr->gc_state = E_EEPROM_XMC1_GC_REQUESTED;
            E_EEPROM_XMC1_lGarbageCollection();

            /*Check the size of the GC requested block to check if space is available in the new bank or not.*/
            flash_blocks = E_EEPROM_XMC1_lGetDFLASHPhysicalBlocks(block_ptr->size);
            remaining_blocks = E_EEPROM_XMC1_lGetFreeDFLASHBlocks();

            /* Check for GC overflows the complete space in the new bank, hence cant write the GC triggered block*/
            if ((remaining_blocks >= flash_blocks)&&(data_ptr->gc_state == E_EEPROM_XMC1_GC_IDLE))
            {
                perform_write = 1U;
            }
            else
            {
                status = (uint32_t)E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED;
            }
        }
        else
        {
            status = (uint32_t)E_EEPROM_XMC1_OPERATION_STATUS_MEMORY_BANK_FULL;
        }
    }
    else
    {
        perform_write = 1U;
    }
    /* Write operation Starts */
    if (perform_write == 1U)
    {
        data_ptr->written_block_counter = 0U;
        if (invalidate == 1U)
        {
            status = E_EEPROM_XMC1_lHandleInvalidReq(block_number, user_block_index);
        }
        else
        {
            status = E_EEPROM_XMC1_lHandleWriteReq(block_number, data_buffer_ptr);
        }
        if (status != 0U)
        {
            status = (uint32_t)E_EEPROM_XMC1_OPERATION_STATUS_FAILURE;
        }
    }
    return (status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lHandleWriteReq
 ********************************************************************************
 * Summary:
 * Handle function to write one complete data block into flash.
 *
 * Parameters:
 * block_number   - User block number / ID
 * data_buffer_ptr - Data buffer address
 *
 * Return:
 * uint32_t - Flash NVM_STATUS register value
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lHandleWriteReq(uint8_t block_number, uint8_t* data_buffer_ptr)
{
    uint32_t block_size;
    uint32_t user_block_index;
    uint32_t status;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_BLOCK_t *block_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);


    user_block_index = E_EEPROM_XMC1_lGetUsrBlockIndex(block_number);
    block_ptr = e_eeprom_xmc1_handle->block_config_ptr + user_block_index;
    block_size = block_ptr->size;
    data_ptr->user_write_bytes_count = 0U;
    data_ptr->user_write_state = E_EEPROM_XMC1_FIRST_BLOCK_WRITE;
    status = 0U;
    do
    {
        switch (data_ptr->user_write_state)
        {
        case E_EEPROM_XMC1_NEXT_BLOCK_WRITE:
            status = E_EEPROM_XMC1_lWriteDataBlock();
            if (status == (uint32_t)0U)
            {
                E_EEPROM_XMC1_lPopulateNextBlock(block_number,data_buffer_ptr,block_size);
            }
            break;

        case E_EEPROM_XMC1_LAST_BLOCK_WRITE:
            status = E_EEPROM_XMC1_lWriteDataBlock();
            if (status == (uint32_t)0U)
            {
                /* Mark the block as inconsistent */
                data_ptr->block_info[user_block_index].address = data_ptr->next_free_block_addr;
                data_ptr->block_info[user_block_index].status.valid = 1U;
                data_ptr->block_info[user_block_index].status.consistent = 1U;
                if (e_eeprom_xmc1_handle->data_block_crc ==1U)
                {
                    /* Updated Cache table Block Header status as CRC enabled block*/
                    data_ptr->block_info[user_block_index].status.crc = 1U;
                }
                else
                {
                    /* Updated Cache table Block Header status as CRC disabled block*/
                    data_ptr->block_info[user_block_index].status.crc = 0U;
                }

                data_ptr->user_write_state = E_EEPROM_XMC1_BLOCK_WRITE_IDLE;
            }
            break;

        default:
            E_EEPROM_XMC1_lPopulateFirstBlock(block_number,data_buffer_ptr,block_size); /* E_EEPROM_XMC1_FIRST_BLOCK_WRITE*/
            break;
        }
    } while ( (status == 0U) && (data_ptr->user_write_state != E_EEPROM_XMC1_BLOCK_WRITE_IDLE) );

    data_ptr->next_free_block_addr = (uint32_t)(data_ptr->next_free_block_addr +
            (data_ptr->written_block_counter * E_EEPROM_XMC1_FLASH_BLOCK_SIZE));
    if (status != 0U)
    {
        data_ptr->block_info[user_block_index].status.valid = 1U;
        data_ptr->block_info[user_block_index].status.consistent = 0U;
    }
    return (status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lHandleInvalidReq
 ********************************************************************************
 * Summary:
 * Write one block with all data element as 0xFF to invalidate a block.
 *
 * Parameters:
 * block_number - User block number / ID
 * user_block_index  - Index of the logical block
 *
 * Return:
 * uint32_t - Flash NVM_STATUS register value
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lHandleInvalidReq(uint8_t block_number, uint32_t  user_block_index)
{
    uint32_t status;
    uint32_t data_byte_count;
    uint8_t* read_write_buffer_ptr;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);
    read_write_buffer_ptr = data_ptr->read_write_buffer;
    *read_write_buffer_ptr = block_number;
    *(read_write_buffer_ptr + 1U) = (E_EEPROM_XMC1_START_BIT);


    for (data_byte_count = E_EEPROM_XMC1_TWO_BYTES;data_byte_count < E_EEPROM_XMC1_FLASH_BLOCK_SIZE;data_byte_count++)
    {
        *((uint8_t *)(void *)(read_write_buffer_ptr + data_byte_count)) = E_EEPROM_XMC1_8BIT_ALL_ONE;
    }

    status = E_EEPROM_XMC1_lWriteDataBlock();

    if (status == 0U)
    {
        data_ptr->block_info[user_block_index].status.consistent = 1U;
        data_ptr->block_info[user_block_index].address = data_ptr->next_free_block_addr;
    }
    else
    {
        data_ptr->block_info[user_block_index].status.consistent = 0U;
    }

    data_ptr->block_info[user_block_index].status.valid = 0U;
    data_ptr->next_free_block_addr = (E_EEPROM_XMC1_FLASH_BLOCK_SIZE + (uint32_t)(data_ptr->next_free_block_addr));

    return (status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lPopulateFirstBlock
 ********************************************************************************
 * Summary:
 * Populates the first block with data elements starting from the passed data
 * buffer address.
 *
 * Parameters:
 * block_number   - User block number / ID
 * data_buffer_ptr - Data buffer address
 * block_size - Length of data to be read
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lPopulateFirstBlock(uint8_t block_number,
        uint8_t* user_data_buffer_ptr,
        uint32_t block_size)
{
    uint32_t crc_bit;
    uint32_t crc_buffer;
    uint32_t data_byte_count;
    uint8_t* read_write_buffer_ptr;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);
    read_write_buffer_ptr = data_ptr->read_write_buffer;
    data_ptr->user_write_state = E_EEPROM_XMC1_NEXT_BLOCK_WRITE;

#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
    /* IF Block CRC is enabled then update the block Header with 16 bit CRC calculated from the data buffer*/
    CRC_SW_CalculateCRC(e_eeprom_xmc1_handle->crc_handle_ptr,user_data_buffer_ptr,block_size);
    crc_buffer = CRC_SW_GetCRCResult(e_eeprom_xmc1_handle->crc_handle_ptr);
    crc_bit = E_EEPROM_XMC1_CRC_BIT;
#else
    crc_buffer = E_EEPROM_XMC1_DUMMY_CRC;
    crc_bit = 0U;
#endif

    /* Populate header block with block number, status bits and CRC buffer. Hence 4 bytes shift for data byte Count*/
    *((uint32_t *)(void *)(read_write_buffer_ptr)) = (uint32_t)((block_number) |
            (uint32_t)((E_EEPROM_XMC1_START_BIT | E_EEPROM_XMC1_VALID_BIT |
                    crc_bit) << E_EEPROM_XMC1_EIGHT_BIT_POS) |
                    (uint32_t)(crc_buffer << E_EEPROM_XMC1_CRC_SHIFT));
    data_byte_count = E_EEPROM_XMC1_FOUR_BYTES;
    /* Add data to the write buffer from the user specified pointer */
    do
    {
        if (data_ptr->user_write_bytes_count < block_size  )
        {
            *(read_write_buffer_ptr + data_byte_count) = *(user_data_buffer_ptr + data_ptr->user_write_bytes_count);
            (data_ptr->user_write_bytes_count)++;
        }
        else
        {
            *(read_write_buffer_ptr + data_byte_count) = E_EEPROM_XMC1_8BIT_ALL_ONE;
        }
        data_byte_count++;

    } while ( data_byte_count != E_EEPROM_XMC1_FLASH_BLOCK_SIZE); /* Check for block size overflow*/

    if (data_ptr->user_write_bytes_count >= block_size)
    {
        data_ptr->user_write_state = E_EEPROM_XMC1_LAST_BLOCK_WRITE;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lPopulateNextBlock
 ********************************************************************************
 * Summary:
 * Populates the successive blocks with data elements starting from the passed data
 * buffer address.
 *
 * Parameters:
 * block_number   - User block number / ID
 * data_buffer_ptr - Data buffer address
 * block_size - Length of data to be read
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lPopulateNextBlock( uint8_t block_number ,
        uint8_t*  const user_data_buffer_ptr ,
        uint32_t block_size)
{
    uint32_t  data_byte_count;
    uint8_t*  read_write_buffer_ptr;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    read_write_buffer_ptr = data_ptr->read_write_buffer;
    *(read_write_buffer_ptr) = block_number;
    *(read_write_buffer_ptr + 1U) = E_EEPROM_XMC1_VALID_BIT;
    data_byte_count = E_EEPROM_XMC1_TWO_BYTES;

    /* Add data to the write buffer from the user specified pointer */
    do
    {
        if (data_ptr->user_write_bytes_count < block_size )
        {
            *(read_write_buffer_ptr + data_byte_count) = *(user_data_buffer_ptr + data_ptr->user_write_bytes_count);
            (data_ptr->user_write_bytes_count)++;
        }
        else
        {
            *(read_write_buffer_ptr + data_byte_count) = E_EEPROM_XMC1_8BIT_ALL_ONE;
            data_ptr->user_write_state = E_EEPROM_XMC1_LAST_BLOCK_WRITE;
        }
        data_byte_count++;

    } while ( data_byte_count != E_EEPROM_XMC1_FLASH_BLOCK_SIZE);

    if (data_ptr->user_write_bytes_count >= block_size)
    {
        data_ptr->user_write_state = E_EEPROM_XMC1_LAST_BLOCK_WRITE;
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lWriteDataBlock
 ********************************************************************************
 * Summary:
 * Writes single data block into flash
 *
 * Parameters:
 * void
 *
 * Return:
 * uint32_t - NVM_STATUS register value after read operation
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lWriteDataBlock(void)
{
    uint32_t status;
    uint32_t src_addr;
    E_EEPROM_XMC1_DATA_t *data_ptr;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);

    src_addr = (uint32_t)(data_ptr->next_free_block_addr +
            (data_ptr->written_block_counter * E_EEPROM_XMC1_FLASH_BLOCK_SIZE));
    (data_ptr->written_block_counter)++;

    XMC_FLASH_ClearStatus();
    E_EEPROM_XMC1_lWriteSingleBlock(src_addr, (uint32_t*)(void*)data_ptr->read_write_buffer);
    status = E_EEPROM_XMC1_lGetFlashStatus();

    return (status);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lReadBlockContents
 ********************************************************************************
 * Summary:
 * Read data bytes starting from specified address (data_buffer_ptr + offset).
 * Read number of bytes as specified in the length parameter.
 *
 * Parameters:
 * data_buffer_ptr - Data buffer address
 * length - Length of data to be read
 * offset - Offset from which the read shall start
 *
 * Return:
 * E_EEPROM_XMC1_STATUS_t
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lReadBlockContents(uint8_t *const data_buffer_ptr, uint32_t length, uint32_t offset)
{
    uint32_t indx;
    uint32_t status;
    uint32_t block_count;
    uint32_t flash_address;
    uint32_t block_start_address;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    uint32_t remaining_bytes_in_curr_block;

    indx = 0U;
    status = 0U;
    block_count = 0U;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);
    block_start_address = data_ptr->read_start_address;

    if (offset >= E_EEPROM_XMC1_BLOCK1_DATA_SIZE)  /* Check if the offset does'nt fit in the first data block.  */
    {
        block_count++;                        /* If not then increment block counter*/
        offset = offset - E_EEPROM_XMC1_BLOCK1_DATA_SIZE;  /* subtract the data size of first block (12 bytes)*/
        while (offset >= E_EEPROM_XMC1_BLOCK2_DATA_SIZE)   /* Check the exact block where the offset fit inside  */
        {
            block_count++;                        /* If not then increment block counter*/
            offset = offset - E_EEPROM_XMC1_BLOCK2_DATA_SIZE; /* subtract the data size of next block (14 bytes)*/
        }
        offset += E_EEPROM_XMC1_BLOCK2_DATA_OFFSET;
    }
    else
    {
        offset += E_EEPROM_XMC1_BLOCK1_DATA_OFFSET;
    }
    /* Remaining bytes in the block where Read offset is pointing*/
    remaining_bytes_in_curr_block = E_EEPROM_XMC1_FLASH_BLOCK_SIZE - offset;

    do
    {
        /* Calculate the Flash address of the block to be read*/
        flash_address = block_start_address + ((uint32_t)block_count * E_EEPROM_XMC1_FLASH_BLOCK_SIZE);

        XMC_FLASH_ClearStatus();
        E_EEPROM_XMC1_lReadSingleBlock(flash_address,(uint32_t*)(void*)data_ptr->read_write_buffer);
        status = E_EEPROM_XMC1_lGetFlashStatus();

        if (status != 0U)
        {
            break;
        }
        /* Extract the data read from flash byte by byte and load into the user buffer*/
        do{

            *(data_buffer_ptr + indx) = *(data_ptr->read_write_buffer + offset);
            indx++;
            offset++;
            length--;
            remaining_bytes_in_curr_block--;

            /* check any of the length parameters reaches 0 */
        } while ( (remaining_bytes_in_curr_block) && (length) );

        /* Check if the length of bytes pending to be read is within the range of available bytes in the block */
        if (length <= E_EEPROM_XMC1_BLOCK2_DATA_SIZE)
        {
            /* Force remaining bytes in current block to length remaining */
            remaining_bytes_in_curr_block = length;
        }
        else
        {
            /* Force remaining bytes to next block size(14)*/
            remaining_bytes_in_curr_block = E_EEPROM_XMC1_BLOCK2_DATA_SIZE;
        }

        offset = E_EEPROM_XMC1_BLOCK2_DATA_OFFSET;     /* Shift offset by 2 counts to avoid next block header */
        block_count++;                        /* Increment the block count to read next block */

    } while (length != 0U);

    return (status);
}

#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lReadBlockCrcStatus
 ********************************************************************************
 * Summary:
 * Reads 16 bit CRC from FLASH block header and verify with the calculated CRC
 * value.
 *
 * Parameters:
 * block_number   - User block number / ID
 * data_buffer_ptr - Data buffer address
 * block_size    - size in bytes of logical block
 *
 * Return:
 * E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS : CRC verification succeeded
 * E_EEPROM_XMC1_OPERATION_STATUS_CRC_FAILED : CRC verification failed
 *
 *******************************************************************************/
static E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_lReadBlockCrcStatus( uint8_t block_number,
        uint8_t *const data_buffer_ptr,
        uint32_t block_size)
{
    uint32_t crc_buffer;
    uint32_t block_index;
    uint32_t crc_read_from_flash;
    E_EEPROM_XMC1_DATA_t *data_ptr;
    E_EEPROM_XMC1_OPERATION_STATUS_t status;

    data_ptr = (E_EEPROM_XMC1_DATA_t*)(void*)(e_eeprom_xmc1_handle->data_ptr);
    crc_buffer = E_EEPROM_XMC1_DUMMY_CRC;
    status = E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS;
    block_index = E_EEPROM_XMC1_lGetUsrBlockIndex(block_number);

    /* Clear all error status flags before flash operation*/
    XMC_FLASH_ClearStatus();

    /* Read the CRC 16 bit data from flash for the particular block */
    crc_read_from_flash = E_EEPROM_XMC1_lReadSingleWord((uint32_t)(data_ptr->block_info[block_index].address));

    /* If CRC is enabled for the block, calculate CRC else use the 16 bit dummy CRC */
    if (data_ptr->block_info[block_index].status.crc == 1U)
    {
        /* IF Block CRC is enabled then update the block Header with 16 bit CRC calculated from the data buffer*/
        CRC_SW_CalculateCRC(e_eeprom_xmc1_handle->crc_handle_ptr,data_buffer_ptr,block_size);
        crc_buffer = CRC_SW_GetCRCResult(e_eeprom_xmc1_handle->crc_handle_ptr);
        /* Check the validity of CRC for the particular block */
        if (crc_buffer != (crc_read_from_flash >> E_EEPROM_XMC1_CRC_SHIFT))
        {
            status = E_EEPROM_XMC1_OPERATION_STATUS_CRC_FAILED;
        }
    }
    else
    {
        /* Check the availability of CRC for the particular block */
        status = E_EEPROM_XMC1_OPERATION_STATUS_NO_CRC_WRITTEN;
    }

    return ((E_EEPROM_XMC1_OPERATION_STATUS_t)status);
}
#endif

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lWriteSingleBlock
 ********************************************************************************
 * Summary:
 * Performs single flash block(16 bytes) write operation
 *
 * Parameters:
 * address  - Flash address
 * data    - Pointer to Data buffer address
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lWriteSingleBlock(uint32_t const address, const uint32_t *const data)
{
#ifdef E_EEPROM_XMC1_TEST_HOOK_ENABLE
    if (e_eeprom_xmc1_test_hook_writeblock == 1U)
    {
        E_EEPROM_XMC1_TEST_HOOK_WriteSingleBlock(address,data);
    }
    else
#endif
    {
        XMC_FLASH_WriteBlocks( (uint32_t*)address, (uint32_t*)data , 1U , 1U);
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lReadSingleBlock
 ********************************************************************************
 * Summary:
 * Performs single flash block(16 bytes) read operation
 *
 * Parameters:
 * address  - Flash address
 * data    - Pointer to Data buffer address
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lReadSingleBlock(uint32_t const address, uint32_t *const data)
{
#ifdef E_EEPROM_XMC1_TEST_HOOK_ENABLE
    if (e_eeprom_xmc1_test_hook_readblock == 1U)
    {
        E_EEPROM_XMC1_TEST_HOOK_ReadSingleBlock(address,data);
    }
    else
#endif
    {
        XMC_FLASH_ReadBlocks( (uint32_t*)address , (uint32_t*)data , 1U);
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lWriteSinglePage
 ********************************************************************************
 * Summary:
 * Performs single flash page(256 bytes) write operation
 *
 * Parameters:
 * address  - Flash address
 * data    - Pointer to Data buffer address
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lWriteSinglePage(uint32_t const address, const uint32_t *const data)
{
#ifdef E_EEPROM_XMC1_TEST_HOOK_ENABLE
    if (e_eeprom_xmc1_test_hook_writepage == 1U)
    {
        E_EEPROM_XMC1_TEST_HOOK_WriteSinglePage(address,data);
    }
    else
#endif
    {
        XMC_FLASH_ProgramPage( (uint32_t*)address , (uint32_t*)data);
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lEraseSinglePage
 ********************************************************************************
 * Summary:
 * Erases single flash page(256 bytes)
 *
 * Parameters:
 * address  - Flash address
 *
 * Return:
 * void
 *
 *******************************************************************************/
static void E_EEPROM_XMC1_lEraseSinglePage(uint32_t const address)
{
#ifdef E_EEPROM_XMC1_TEST_HOOK_ENABLE
    if (e_eeprom_xmc1_test_hook_erasepage == 1U)
    {
        E_EEPROM_XMC1_TEST_HOOK_EraseSinglePage(address);
    }
    else
#endif
    {
        XMC_FLASH_ErasePages( (uint32_t*)address , 1U);
    }
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lReadSingleWord
 ********************************************************************************
 * Summary:
 * Performs single word(4 bytes) read operation from flash
 *
 * Parameters:
 * address  - Flash address
 *
 * Return:
 * uint32_t  - Word data read from flash address
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lReadSingleWord(uint32_t const address)
{
    uint32_t read_word;
#ifdef E_EEPROM_XMC1_TEST_HOOK_ENABLE
    if (e_eeprom_xmc1_test_hook_readword == 1U)
    {
        read_word = E_EEPROM_XMC1_TEST_HOOK_ReadSingleWord(address);
    }
    else
#endif
    {
        read_word = XMC_FLASH_ReadWord((uint32_t*)address);
    }
    return (read_word);
}

/*******************************************************************************
 * Function Name: E_EEPROM_XMC1_lGetFlashStatus
 ********************************************************************************
 * Summary:
 * Reads the flash status from hardware to check whether any error exist or not.
 *
 * Parameters:
 * void
 *
 * Return:
 * uint32_t  - Flash NVM_STATUS register value
 *
 *******************************************************************************/
static uint32_t E_EEPROM_XMC1_lGetFlashStatus(void)
{
    uint32_t status;
#ifdef E_EEPROM_XMC1_TEST_HOOK_ENABLE
    if (e_eeprom_xmc1_test_hook_getflashstatus == 1U)
    {
        status = E_EEPROM_XMC1_TEST_HOOK_GetFlashStatus();
    }
    else
#endif
    {
        status = XMC_FLASH_GetStatus();
    }
    return (status);
}
/*CODE_BLOCK_END*/
#endif
