/******************************************************************************
* File Name:   e_eeprom_xmc1.h
*
* Description: Header file for emulated EEPROM implementation in XMC1000 MCUs.
* It contains the necessary macro and structure definitions to use configure
* flash memory as emulated EEPROM.
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
*****************************************************************************
* Change History
* --------------
*
* 2015-02-16:
*     - Initial version<br>
*
* 2015-04-24:
*     - E_EEPROM_XMC1_ReadBlockWithCRC API renamed to
*     E_EEPROM_XMC1_VerifyBlockCrcStatus<br>
*     - E_EEPROM_XMC1_OPERATION_STATUS_t enumeration parameter names
*     changed and additional status parameter
*       E_EEPROM_XMC1_OPERATION_STATUS_NO_CRC_WRITTEN added.
*
* 2016-07-08:
*     - Fixed incorrect case for an included header.
*
* 2021-01-08:
*     - Modified check for minimum XMCLib version
*
* 2022-03-02:
*     - Adapted for use with mtb-xmc-emeeprom asset
*****************************************************************************/

#ifndef E_EEPROM_XMC1_H
#define E_EEPROM_XMC1_H

/*****************************************************************************
 * HEADER FILES
 ****************************************************************************/

/**
********************************************************************************
* \mainpage Em_EEPROM Middleware Library
*
* The Emulated EEPROM (Em_EEPROM) middleware emulates an EEPROM storage in
* XMC1000 internal flash memory. The Em_EEPROM middleware operates on the top
* of the flash driver included in the XMCLib CAT3 Peripheral Driver Library.
*
* Use the Em_EEPROM to store non-volatile data on a target device when
* increasing flash memory endurance is required.
*
* Please note the Internal Flash reserved by EEPROM middleware when using
* this asset.
*
* <b>Features:</b>
* * EEPROM-Like Non-Volatile Storage
* * Easy to use Read and Write
*
********************************************************************************
* \section section_em_eeprom_general_description General Description
********************************************************************************
*
* The XMC1000 emulated EEPROM support is provided with the APIs described
* below.
*
* It should be noted that the non-volatile memory required to store the EEPROM
* Data is mapped to Internal Flash. In the XMC 1xxx emulated EEPROM Middleware
* the Flash region required for EEPROM is allocated at the very End of Internal
* Flash. It is advisable for user(s) of emulated EEPROM to update (modify) their
* Linker file (script) to reduce the amount of Flash available for code and
* initialized data.
*
*
*
********************************************************************************
* \section section_em_eeprom_linker_script_update Linker Script Updates
********************************************************************************
*
* It should be noted that the non-volatile memory required to store the EEPROM
* Data is mapped to Internal Flash. In the XMC 1xxx emulated EEPROM Middleware
* the Flash region required for EEPROM is allocated at the very End of Internal
* Flash. The amount of Flash space reserved can be calculated using the
* macro: E_EEPROM_XMC1_FLASH_TOTAL_SIZE an internal usage macro defined in code.
* It is advisable for user(s) of emulated EEPROM to update (modify) their
* Linker file (script) to reduce the amount of Flash available for code and
* initialed data by the size reserved for EEPROM size desired by application.
* This will remove the mapped region of Flash form being used for code or
* initialized data. When properly updated linker script is used and if
* the user application grows such that it overlaps the Flash region utilized by
* EEPROM, there will linking errors during the build.
*
* For the Kit/XMC device you are using, please select the proper Linker script.
* For Infineon ModusToolbox targets, the GCC_ARM and ARM linker scripts are
* present in target for the kit under TOOLCHAIN_GCC_ARM and TOOLCHAIN_ARM.
* For IAR, please make a copy of the IAR linker script from the IAR toolchain
* and edit it for the Project using XMC1xxx Emulated EEPROM.
* Note - the ModusToolBox allows use of custom Linker script by editing in
* Makefile the tag LINKER_SCRIPT=\<path to custom linker script\>.
*
* Examples of how the linker scripts be modified is provided below.
* Assumption for the explanation of Linker scripts changes is that the Flash
* reserved for EEPROM is 4 KBytes (0x1000).
* For user required EEPROM size please determine the size of Flash needed
* to be reserved from the the output of
* macro: E_EEPROM_XMC1_FLASH_TOTAL_SIZE for given EEPROM size and make
* appropriate changes..
*
*
* Example of GCC_ARM Linker script for XMC1200x0200 Kit/Device (XMC1200x0200.ld):
*
* Original Linker script Memory map and sections:
*
* \code
* MEMORY
* {
*
*     FLASH(RX) : ORIGIN = 0x10001000, LENGTH = 0x32000
*
*     SRAM(!RX) : ORIGIN = 0x20000000, LENGTH = 0x4000
*
* }
* \endcode
*
*
* Modified Linker script Memory map (4 KBytes reserved for EEPROM):
*
* \code
* MEMORY
* {
*
*    FLASH(RX) : ORIGIN = 0x10001000, LENGTH = 0x31000
*
*    SRAM(!RX) : ORIGIN = 0x20000000, LENGTH = 0x4000
*
* }
* \endcode
*
*
* Example of ARM Linker script for XMC1200x0200 Kit/Device (XMC1200x0200.sct):
*
* Original Linker Memory map:
*
* \code
* #define __ROM_BASE     0x10001000
*
* #define __ROM_SIZE     0x00032000
* \endcode
*
*
* Modified Linker Memory map (4 KBytes reserved for EEPROM):
*
* \code
* #define __ROM_BASE     0x10001000
*
* #define __ROM_SIZE     0x00031000
* \endcode
*
*
* Example of IAR Linker script for XMC1200x0200 Kit/Device (XMC1200xxxxx200.icf):
*
* Original Linker Memory map:
*
* \code
* define symbol __ICFEDIT_region_ROM_start__ = 0x10001000;
*
* define symbol __ICFEDIT_region_ROM_end__   = 0x10032FFF;
*
* define symbol __ICFEDIT_region_RAM_start__ = 0x20000000;
*
* define symbol __ICFEDIT_region_RAM_end__   = 0x20003FFF;
* \endcode
*
*
* Modified Linker Memory map (4 KBytes reserved for EEPROM):
*
* \code
* define symbol __ICFEDIT_region_ROM_start__ = 0x10001000;
*
* define symbol __ICFEDIT_region_ROM_end__   = 0x10031FFF;
*
* define symbol __ICFEDIT_region_RAM_start__ = 0x20000000;
*
* define symbol __ICFEDIT_region_RAM_end__   = 0x20003FFF;
* \endcode
*
*
*
*
********************************************************************************
* \section section_em_eeprom_app_usage Application Configuration and API Usage
********************************************************************************
*
* 
* The XMC1 Emulated EEPROM asset can be used to store non-volatile data in Flash
* with improved resiliency. In XMC1 emulated eeprom is stored in Flash at the very
* end. When compiling the XMC1 eeprom asset the macro: E_EEPROM_XMC1_FLASH_EEPROM_SIZE
* has to be defined to the size of the EEPROM region required. This definition can be
* provided through the EEPROM Personality in ModusToolbox or passed as
* DEFINE+=E_EEPROM_XMC1_FLASH_EEPROM_SIZE="desired size".
* Note - the size of EEPROM should be larger than the sum of All the blocks that are
* configured in the XMC1 EEPROM configuration structure. This will allow multiple
* updates in current flash bank before need for Garbage collection to next bank.
 * This improves the flash resiliency. The region of flash that will be used for
* storage should be erased before the first time it is used to map EEPROM data.
* After using region for EEPROM, this region should not be erased unless it is
* explicitly desired to get rid of previously stored EEPROM data.
* 
* The XMC1 EEPROM has a complex configuration and handle data structure which passes
* in the initial configuration information and it also stores the run-time data
* needed for subsequent API execution. The XMC Configuration data structure is:
* 
* Data structure to configure the APP properties. Use @ref E_EEPROM_XMC1_t type
* for accessing the members *
* typedef struct E_EEPROM_XMC1
* {
*   E_EEPROM_XMC1_BLOCK_t *block_config_ptr; // **< Pointer to user block configurations *
* 
*   E_EEPROM_XMC1_DATA_t *data_ptr; // **< Pointer to the state variable data structure *
* 
*   \#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
*
*   CRC_SW_t* const crc_handle_ptr;  // **< CRC APP handle pointer*
*
*   \#endif
* 
*   E_EEPROM_XMC1_STATUS_t  state; // **< Current state of the APP instance*
* 
*   const uint8_t  block_count; // **< Number of configured user data blocks *
* 
*   const uint8_t  erase_all_auto_recovery; // **< Erase Complete emulation area and recover to default state *
* 
*   const uint8_t  data_block_crc; // **< Allow to calculate CRC for each data block on write *
* 
*   const uint8_t  garbage_collection; // **< Enables garbage collection when no space available for new write*
* 
* } E_EEPROM_XMC1_t;
* 
* The application should decide the number of blocks that are needed
* by it (block_count) and provide 2 arrays of size block_count,
* namely: block_config_ptr[block_count] and data_ptr[block_count]. Note: the maximum
* block_count supported is 10.
*
* The first array block_config_ptr[block_count] is the configuration information
* of "block number" and "size" for each block in EEPROM. Note the Size of EEPROM
* (E_EEPROM_XMC1_FLASH_EEPROM_SIZE) provided by Personality/Define via Makefile
* should definitely be much larger than the sum of All the block sizes defined
* in this configuration data structure. Giving a much larger value will
* reserve more Flash at the end of Flash block but will increase the flash resiliency.
* The maximum block size size supported is 32 KBytes bytes and the minimum is 1 byte.
* 
* The configuration parameter "crc_handle_ptr" can be set to "CRC_SW_0" to use
* the CRC sw bundled with the asset if CRC is to be enabled.
* 
* The data structure parameter: state is Not a configuration parameter.
* 
* The Configuration parameter "block_count" denotes the number of user "blocks"
* Note XMC1 API support read/write only on block basis.
* 
* The configuration parameter: erase_all_auto_recovery" should be usually
* 0 (off). It can be used to erase Flash but should Not be set (1) during
* regular execution otherwise EEPROM data will be lost on every reboot.
* 
* The configuration parameter: data_black_crc, should be set if CRC protection
* is required. Note - when setting this, the "crc_handle_ptr" should also
* be enabled.
* 
* The configuration parameter: garbage_collection, when set to 1, will enable
* Automatic garbage collection. If user does Not want automatic garbage
* collection, then they have to explicitly check in run time code, whether
* garbage collection is needed and explicitly call it.
* 
*
* Typical EEPROM asset API sequence can be: E_EEPROM_XMC1_Init(&E_EEPROM_XMC1_handle);
* and then read/write APIs:
* E_EEPROM_XMC1_Write(blockNum, data_wbuffer);
* E_EEPROM_XMC1_Read(blockNum, 0U, data_rbuffer, block_size);
* 
* 
* 
********************************************************************************
*
*
* \defgroup E_EEPROM_XMC1_enumerations Enumerations
* \brief
* This section describes the Emulated EEPROM Macros.
*
* \defgroup E_EEPROM_XMC1_datastructures Data Structures
* \brief
* This section describes the data structures defined by the Emulated EEPROM.
*
* \defgroup E_EEPROM_XMC1_functions Functions
* \brief
* This section describes the public APIs defined by the Emulated EEPROM.
*
*
*/

#include "xmc_flash.h"
#include "cycfg.h"


/*
 *  Flash address and Size information as per user configuration
 */

#ifndef E_EEPROM_XMC1_FLASH_EEPROM_SIZE
#if UC_FAMILY == XMC1       /* Need EEPROM Size for XMC1 - No defaults */
#error "Need to define E_EEPROM_XMC1_FLASH_EEPROM_SIZE using Personality or Makefile define"
#else /* UC_FAMILY == XMC1 */
#define E_EEPROM_XMC1_FLASH_EEPROM_SIZE  (500) /* Dummy value (not used) for compilation of XMC4 EEPROM files */
#endif /* US_FAMILY == XMC1 */
#endif

#if ((E_EEPROM_XMC1_FLASH_EEPROM_SIZE < 256) || (E_EEPROM_XMC1_FLASH_EEPROM_SIZE > 50944))
#error "EEPROM SIZE IS INCORRECT. It should be between 256 and 50944"
#endif


#define E_EEPROM_XMC1_FLASH_BANK_SIZE      (((((E_EEPROM_XMC1_FLASH_EEPROM_SIZE - 1) \
                                           / XMC_FLASH_BYTES_PER_PAGE) + 1) \
                                           * XMC_FLASH_BYTES_PER_PAGE) + XMC_FLASH_BYTES_PER_PAGE)

#define E_EEPROM_XMC1_FLASH_TOTAL_SIZE     (E_EEPROM_XMC1_FLASH_BANK_SIZE * 2)

#define E_EEPROM_XMC1_FLASH_BANK1_END      (XMC_FLASH_BASE + ((UC_FLASH * 1024UL) - 1))
#define E_EEPROM_XMC1_FLASH_BANK1_BASE     (E_EEPROM_XMC1_FLASH_BANK1_END - E_EEPROM_XMC1_FLASH_BANK_SIZE + 1)
#define E_EEPROM_XMC1_FLASH_BANK0_END      (E_EEPROM_XMC1_FLASH_BANK1_BASE - 1)
#define E_EEPROM_XMC1_FLASH_BANK0_BASE     (E_EEPROM_XMC1_FLASH_BANK0_END - E_EEPROM_XMC1_FLASH_BANK_SIZE + 1)

/*
 *  Total number of pages per bank, resulting after division of banks
 *  i.e. E_EEPROM_XMC1_BANK_PAGES = (E_EEPROM_XMC1_FLASH_TOTAL_SIZE in Bytes / ((256 Bytes * 2 Banks))
 */
#define E_EEPROM_XMC1_BANK_PAGES           (E_EEPROM_XMC1_FLASH_TOTAL_SIZE / (XMC_FLASH_BYTES_PER_PAGE * 2))

#if (E_EEPROM_XMC1_FLASH_TOTAL_SIZE > (((UC_FLASH * 1024UL) / 2UL) - 1024UL))
#error "EEPROM SIZE IS ALMOST HALF FLASH SIZE FOR DEVICE. THIS CONFIGURATION IS NOT SUPPORTED"
#endif


#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
#include "xmc_crc_sw.h"
#endif

/*****************************************************************************
 * MACROS
 ****************************************************************************/
#define E_EEPROM_XMC1_XMC_LIB_MAJOR_VERSION 2
#define E_EEPROM_XMC1_XMC_LIB_MINOR_VERSION 0
#define E_EEPROM_XMC1_XMC_LIB_PATCH_VERSION 0

#if !((XMC_LIB_MAJOR_VERSION > E_EEPROM_XMC1_XMC_LIB_MAJOR_VERSION) ||\
      ((XMC_LIB_MAJOR_VERSION == E_EEPROM_XMC1_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION > E_EEPROM_XMC1_XMC_LIB_MINOR_VERSION)) ||\
      ((XMC_LIB_MAJOR_VERSION == E_EEPROM_XMC1_XMC_LIB_MAJOR_VERSION) && (XMC_LIB_MINOR_VERSION == E_EEPROM_XMC1_XMC_LIB_MINOR_VERSION) && (XMC_LIB_PATCH_VERSION >= E_EEPROM_XMC1_XMC_LIB_PATCH_VERSION)))
#error "E_EEPROM_XMC1 requires XMC Peripheral Library v2.0.0 or higher"
#endif

/** Physical flash Block size and Page size defined*/
#define E_EEPROM_XMC1_FLASH_BLOCK_SIZE  (16U)
#define E_EEPROM_XMC1_FLASH_PAGE_SIZE   (256U)

/*
 *  These are global variables used only for internal testing purpose.
 *  Application code shall not use these variables by enabling E_EEPROM_XMC1_TEST_HOOK_ENABLE macro definition.
 */
#ifdef E_EEPROM_XMC1_TEST_HOOK_ENABLE
uint32_t e_eeprom_xmc1_test_hook_readblock;
uint32_t e_eeprom_xmc1_test_hook_writeblock;
uint32_t e_eeprom_xmc1_test_hook_writepage;
uint32_t e_eeprom_xmc1_test_hook_erasepage;
uint32_t e_eeprom_xmc1_test_hook_readword;
uint32_t e_eeprom_xmc1_test_hook_getflashstatus;
#endif

/*****************************************************************************
* ENUMS
*****************************************************************************/

/**
* \addtogroup E_EEPROM_XMC1_enumerations
* \{
*/

/** Defines the error codes for E_EEPROM_XMC1 APP. */
typedef enum E_EEPROM_XMC1_STATUS
{
  E_EEPROM_XMC1_STATUS_SUCCESS        = 0U, /**< Successful completion of APP initialization */
  E_EEPROM_XMC1_STATUS_FAILURE        = 1U, /**< Initialization failed due to internal operational error*/
  E_EEPROM_XMC1_STATUS_UNINITIALIZED  = 2U, /**< APP is in Uninitialized state*/
  E_EEPROM_XMC1_STATUS_IDLE           = 3U, /**< APP is in IDLE state. Only used in E_EEPROM_XMC1_GetStatus() API */
  E_EEPROM_XMC1_STATUS_BUSY           = 4U  /**< APP is in BUSY state. Only used in E_EEPROM_XMC1_GetStatus() API */
} E_EEPROM_XMC1_STATUS_t;

/**
 * Defines current status for E_EEPROM_XMC1 APP.
 */

typedef enum E_EEPROM_XMC1_OPERATION_STATUS
{
  E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS            = 0U, /**< Successful completion of operation*/
  E_EEPROM_XMC1_OPERATION_STATUS_FAILURE            = 1U, /**< APP failed due to internal flash operational errors*/
  E_EEPROM_XMC1_OPERATION_STATUS_INCONSISTENT_BLOCK = 2U, /**< Targeted block is inconsistent*/
  E_EEPROM_XMC1_OPERATION_STATUS_INVALID_BLOCK      = 3U, /**< The latest copy of the targeted block was invalidated */
  E_EEPROM_XMC1_OPERATION_STATUS_CRC_FAILED         = 4U, /**< CRC verification failed for the targeted block*/
  E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED        = 5U, /**< Operation not allowed to continue*/
  E_EEPROM_XMC1_OPERATION_STATUS_MEMORY_BANK_FULL   = 6U, /**< Write/Invalidate operation failed when bank has no space.
                                                             Call E_EEPROM_XMC1_StartGarbageCollection API to proceed */
  E_EEPROM_XMC1_OPERATION_STATUS_NO_CRC_WRITTEN     = 7U  /**< Written block does not have CRC checksum enabled.*/
} E_EEPROM_XMC1_OPERATION_STATUS_t;

/**
 * @}
 */

/**
* \addtogroup E_EEPROM_XMC1_datastructures
* \{
*/
/*****************************************************************************
 * * DATA STRUCTURES
*****************************************************************************/

/**  Data structure to configure the Data Block parameters */
typedef struct E_EEPROM_XMC1_BLOCK
{
  uint8_t block_number; /**< Logical block number (Block ID) */

  uint32_t size; /**< Size of the logical block */

} E_EEPROM_XMC1_BLOCK_t;


/** Data structure to hold the header information about a particular user data block */
typedef struct E_EEPROM_XMC1_BLOCK_HEADER
{
  uint8_t block_number; /**< User data block number */

  uint8_t status; /**< User data block status */

} E_EEPROM_XMC1_BLOCK_HEADER_t;


/*lint -e46 */
/** Bit field data structure holds the overall information about a particular user data block */
typedef struct E_EEPROM_XMC1_CACHE_STATUS
{
  uint32_t valid      : 1; /**< Indicates the data block stored in the flash is valid or invalid */

  uint32_t consistent : 1; /**< Indicates the data block stored in the flash is faulty or not */

  uint32_t copied     : 1; /**< Indicates the data blocks are copied or not to free bank during GC */

  uint32_t crc        : 1; /**< Indicates if the block is enabled with a valid 16 bit CRC */

  uint32_t unused     : 28; /**< unused */

} E_EEPROM_XMC1_CACHE_STATUS_t;
/*lint -e46 */


/** Data structure to hold the information about the physical address and status of a user data block */
typedef struct E_EEPROM_XMC1_CACHE
{
  uint32_t address; /**< It has the actual physical address of the flash where the written data block starts */

  E_EEPROM_XMC1_CACHE_STATUS_t status; /**< Status information of the written user data block (Valid/Consistent/CRC)*/

} E_EEPROM_XMC1_CACHE_t;


/** Data structure to hold the count of flash physical blocks and status of a user data block */
typedef struct E_EEPROM_XMC1_TRAVERSE_BLOCK_RESULT
{
  uint32_t block_count; /**< Number of physical flash blocks required for a particular data block */

  E_EEPROM_XMC1_CACHE_STATUS_t status; /**< status of the user data block */

} E_EEPROM_XMC1_TRAVERSE_BLOCK_RESULT_t;


/** Data structure to hold the complete state data information of Emulation APP (Run Time Handler)*/
typedef struct E_EEPROM_XMC1_DATA
{
  E_EEPROM_XMC1_CACHE_t *block_info;/**< User data block information */

  E_EEPROM_XMC1_TRAVERSE_BLOCK_RESULT_t block_result; /**< get previous data block read result information */

  uint32_t  current_bank;  /**< Stores the current Bank on which blocks write operation will be done */

  uint32_t  gc_dest_addr; /**< Destination address for copying data during GC */

  uint32_t  gc_src_addr; /**< Source address from which data needs to be copied during GC */

  uint32_t  curr_bank_end_addr; /**< Current bank end address */

  uint32_t  prev_bank_end_addr; /**< previous bank end address */

  uint32_t  next_free_block_addr; /**< Stores the next available flash address for next block write */

  uint32_t  curr_bank_src_addr; /**< Used for cache update and later stores the current Bank base address */

  uint32_t  gc_block_counter; /**< Tracks number of flash blocks read/written during GC process */

  uint32_t  written_block_counter; /**< Keeps track of the number of flash blocks written for an user data block */

  uint8_t   read_write_buffer[E_EEPROM_XMC1_FLASH_BLOCK_SIZE]; /**< Internal buffer to load and store single block */

  uint32_t  crc_buffer; /**< Keeps track the CRC 16 bit CRC value */

  uint8_t   page_write_buffer[E_EEPROM_XMC1_FLASH_PAGE_SIZE]; /**< Internal buffer to load and store single page */

  uint32_t  user_write_bytes_count; /**< Keeps track of the number of bytes written */

  uint32_t  gc_state; /**< State variable to keep track of the current state of the garbage collection procedure */

  uint32_t  init_gc_state; /**< Stores the current state for initialization process */

  uint32_t  gc_log_block_count; /**< Tracks the number of logical blocks covered during GC process  */

  uint32_t  cache_state; /**< Stores current state of the cache update process */

  uint32_t  updated_cache_index; /**< Keeps track of the current block for which cache update is ongoing */

  uint32_t  user_write_state; /**< Current status of the user write */

  uint32_t  read_start_address; /**< Current flash starting address to read the data */

} E_EEPROM_XMC1_DATA_t;


/** Data structure to configure the APP properties. Use @ref E_EEPROM_XMC1_t type for accessing the members */
typedef struct E_EEPROM_XMC1
{
  E_EEPROM_XMC1_BLOCK_t *block_config_ptr; /**< Pointer to user block configurations */

  E_EEPROM_XMC1_DATA_t *data_ptr; /**< Pointer to the state variable data structure */

  #ifdef E_EEPROM_XMC1_CRC_SW_ENABLED
  CRC_SW_t* const crc_handle_ptr;  /**< CRC APP handle pointer*/
  #endif

  E_EEPROM_XMC1_STATUS_t  state; /**< Current state of the APP instance*/

  const uint8_t  block_count; /**< Number of configured user data blocks */

  const uint8_t  erase_all_auto_recovery; /**< Erase Complete emulation area and recover to default state */

  const uint8_t  data_block_crc; /**< Allow to calculate CRC for each data block on write */

  const uint8_t  garbage_collection; /**< Enables garbage collection when no space available for new write*/

} E_EEPROM_XMC1_t;

typedef E_EEPROM_XMC1_t* E_EEPROM_XMC1_HANDLE_PTR_t; /**< Defines a pointer to APP Handle*/

/**
 *@}
 */

#ifdef __cplusplus
extern "C"  {
#endif

/*****************************************************************************
 * API Prototypes
 ****************************************************************************/

/**
* \addtogroup E_EEPROM_XMC1_functions
* \{
*/

/**
 * @brief Initializes E_EEPROM_XMC1 APP with the associated configuration handle.
 * @param handle_ptr : Pointer to the handler of the instance for which this API is called<BR>
 *
 * @return<BR> E_EEPROM_XMC1_STATUS_SUCCESS if initialization is successful else E_EEPROM_XMC1_STATUS_FAILURE<BR>
 *
 * \par<b>Description:</b><br>
 *  Configures and initializes the micro-controller flash as an EEPROM associated with the instance handler.
 *  Performs three basic functionalities to support EEPROM related operations.\n\n
 * <OL>
 * <LI><b>Detection of active flash bank and process selection</b></LI><BR>
 *      Reading the marker states from first page of each flash bank detects the active bank and the free bank.
 *      Detection of active flash bank decides the respective process of state machine\n\n
 * <LI><b>State machine process handling</b></LI><BR>
 *      The state machine process finds free space in the flash for writing user data blocks.
 *      If the detection of active bank fails due to corrupted markers, the state machine results in a non recoverable
 *      state. If the configuration option "Erase all and recover" is enabled, the state machine process will bring
 *      the flash to normal state by formatting the flash banks. Else it stalls the initialization until the flash
 *      banks are erased by calling the xmc1_flash low level driver API's.\n\n
 * <LI><b>Building RAM look up table</b></LI><BR>
 *    The RAM lookup table keeps the track of the user data blocks written into flash. The lookup table has the
 *    complete information about a configured user data block.\n\n
 * </OL>
 * <b>IMPORTANT : </b> This API must be successfully called before calling any other E_EEPROM_XMC1 API.<BR>
 *
 */
 E_EEPROM_XMC1_STATUS_t E_EEPROM_XMC1_Init(E_EEPROM_XMC1_t *const handle_ptr);

 /**
 * @brief Programs the user defined data block into the flash.
 * @param block_number : Block ID Name/Number configured in the block table. Use the names defined in
 *                @ref E_EEPROM_XMC1_BLOCK_t configuration structure array.
 * @param data_buffer_ptr : Pointer to the user data buffer which need to be stored in flash
 *
 * @return <BR>
 *    E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if the write operation is successful<BR>
 *    E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED, if APP initialization is not completed or flash is busy<BR>
 *    E_EEPROM_XMC1_OPERATION_STATUS_MEMORY_BANK_FULL, if no space available in flash bank to write the block<BR>
 *    E_EEPROM_XMC1_OPERATION_STATUS_FAILURE, if write failed due to internal flash errors<BR>
 *
 * \par<b>Description:</b><br>
 *  The requested data block is written into the flash immediately, only when free space is available in flash bank.
 *  On non availability of space in active flash bank, the write gets  delayed due to Garbage Collection.
 *<b>IMPORTANT : </b> This API shall be called only after the successful completion of E_EEPROM_XMC1_Init() API.<BR>
 *              While flash programming operation is in progress, the flash array will be busy and no access to
 *              flash is possible. Hence all other critical functionalities shall be done prior to the execution
 *              of this function.
 *
 *<b>NOTE :</b><BR> It is advised to call this API when the APP in is IDLE state. This can be checked by calling
 *            E_EEPROM_XMC1_GetStatus() API and verifying the status.\n\n
 *
 *<b>Related APIs : </b><BR>  None\n\n
 *
 */
 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_Write(uint8_t block_number, uint8_t *data_buffer_ptr);

 /**
 * @brief Reads the data block contents from flash for the requested block number.
 * @param block_number : Block ID Name/Number configured in the block table. Use the names defined in
 *                @ref E_EEPROM_XMC1_BLOCK_t configuration structure array.
 * @param block_offset : Offset position to start the read operation<BR>
 *                Range [0 - (Block size - 1)]
 * @param data_buffer_ptr : Pointer to the data buffer where data has to be stored after read
 * @param length : Number of the data block elements to be read from the FLASH<BR>
 *            Range [1 - (block size - block_offset)]
 *
 * @return <BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if read operation from flash is successful<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_FAILURE, if read failed due to ECC errors<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED, if APP initialization is not completed or flash is busy<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_INCONSISTENT_BLOCK, if the targeted block was not written properly<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_INVALID_BLOCK, if the targeted block was invalidated<BR>
 *
 * \par<b>Description:</b><br>
 *  Reads the data elements starting from the specified offset location. The number of elements read from the flash is
 *  equal to the length specified as input parameter.
 *
 * <b>IMPORTANT : </b> This API do not perform any CRC verification for the read data.
 *
 * <b>NOTE :</b><BR> If the flash is in busy state, the read will not be accepted.
 *
 */
 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_Read(uint8_t block_number,
                                                    uint32_t block_offset,
                                                    uint8_t *data_buffer_ptr,
                                                    uint32_t length );

 /**
 * @brief Executes garbage collection at runtime.
 * @param :
 * @return <BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if garbage collection is successful<BR>
 *     Else return E_EEPROM_XMC1_OPERATION_STATUS_FAILURE on internal flash errors<BR>
 *
 * \par<b>Description:</b><br>
 *  Performs an explicit Garbage collection any time during the execution of APP. The function is
 *  accepted only if the E_EEPROM_XMC1 is in IDLE state.
 *
 *<b>NOTE :</b><BR> If the flash is busy this will not be processed. It will check for any read write or erase errors
 *            and if any errors present it will return error.
 *
 */
 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_StartGarbageCollection(void);

 /**
 * @brief Invalidate the user defined data block that was written into the flash.
 * @param block_number : Block ID Name/Number configured in the block table
 *
 * @return <BR>
 *    E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if the write operation is successful<BR>
 *    E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED, if APP initialization is not completed or flash is busy<BR>
 *    E_EEPROM_XMC1_OPERATION_STATUS_MEMORY_BANK_FULL, if no space available in flash bank to write the block<BR>
 *    E_EEPROM_XMC1_OPERATION_STATUS_FAILURE, else failed due to internal flash errors<BR>
 *
 * \par<b>Description:</b><br>
 *  The invalidated block is written into the flash immediately, only when free space is available in flash bank.
 *  On non availability of space in active flash bank, the invalidate write gets delayed due to Garbage Collection.
 * <b>IMPORTANT : </b> This API shall be called only after the successful completion of E_EEPROM_XMC1_Init() API.<BR>
 *              While flash programming operation is in progress, the flash array will be busy and no access to
 *              flash is possible. Hence all other critical functionalities shall be done prior to the execution
 *              of this function.
 *
 * <b>NOTE :</b><BR> It is advised to call this API when the APP in is IDLE state. This can be checked by calling
 *            E_EEPROM_XMC1_GetStatus() API and verifying the status.\n\n
 *
 * <b>Related APIs : </b><BR>  None\n\n
 *
 */
 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_InvalidateBlock(uint8_t block_number);

/**
 * @brief Checks the status of APP.
 * @param :
 *
 * @return <BR>
 *        E_EEPROM_XMC1_STATUS_IDLE, if APP is in IDLE state to accept any request<BR>
 *        E_EEPROM_XMC1_STATUS_FAILURE, if any previous operation on APP failed due to some internal error<BR>
 *        E_EEPROM_XMC1_STATUS_BUSY, Else APP is in busy state because of flash operations<BR>
 *
 * \par<b>Description:</b><br>
 *  Read the current status of APP.
 *
 */
 E_EEPROM_XMC1_STATUS_t E_EEPROM_XMC1_GetStatus(void);

/**
 * @brief Check the availability of space in flash bank to write the data block.
 * @param block_number : Block ID Name/Number configured in the block table. Use the names defined in
 *                @ref E_EEPROM_XMC1_BLOCK_t configuration structure array.
 *
 * @return  <BR>
 *        true, if the bank has no space to write the requested block, else returns false.
 *
 * \par<b>Description:</b><br>
 *  During any time of the execution,the need for Garbage collection can be decided by calling this API. This will help
 *  to save time in the runtime write process which triggers a garbage collection automatically.
 *
 * <b>IMPORTANT : </b> This API shall be called only after the successful completion of E_EEPROM_XMC1_Init() API.<BR>
 *
 * <b>NOTE :</b><BR> After initialization of the APP, calling this API can decide the need for Garbage collection.
 *            If this API returns true an explicit garbage collection can be done by calling the API
 *            E_EEPROM_XMC1_StartGarbageCollection().
 *
 */
 bool E_EEPROM_XMC1_IsGarbageCollectionNeeded(uint8_t block_number);

#ifdef E_EEPROM_XMC1_CRC_SW_ENABLED

 /**
 * @brief Reads complete data block from flash and verify the data integrity using CRC checksum.
 * @param block_number : Block ID Name/Number configured in the block table. Use the names defined in
 *                       @ref E_EEPROM_XMC1_BLOCK_t configuration structure array.
 * @param data_buffer_ptr : Pointer to the data buffer where data has to be stored after read
 *
 * @return <BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if read operation from flash is successful<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_FAILURE, if read failed due to ECC errors<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED, if APP initialization is not completed or flash is busy<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_INCONSISTENT_BLOCK, if the targeted block was not written properly<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_INVALID_BLOCK, if the targeted block was invalidated<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_NO_CRC_WRITTEN, if the targeted block was written before without CRC enabled<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_CRC_FAILED, else CRC verification failed for the targeted block<BR>
 *
 * \par<b>Description:</b><br>
 *  Reads 16 bit CRC from header block. CRC checksum for the complete data block is calculated and compared with the
 *  16 bit CRC read from header block. The API return success only if both the calculated CRC and written CRC matches.
 *
 *  <b>NOTE :</b><BR> If the flash is busy this will not be processed.
 *
 */
 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_VerifyBlockCrcStatus(uint8_t block_number, uint8_t *data_buffer_ptr);

#endif

 /**
 * @brief Reads the just previous copy of the block from flash for the requested block number.
 * @param block_number : Block ID Name/Number configured in the block table. Use the names defined in
 *                @ref E_EEPROM_XMC1_BLOCK_t configuration structure array.
 * @param block_offset : Offset position to start the read operation<BR>
 *                Range [0 - (Block size - 1)]
 * @param data_buffer_ptr : Pointer to the data buffer where data has to be stored after read
 * @param length : Number of the data block elements to be read from the FLASH<BR>
 *            Range [1 - (block size - block_offset)]
 *
 * @return <BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_SUCCESS, if read operation from flash is successful<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_FAILURE, if read failed due to ECC errors<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_NOT_ALLOWED, if APP initialization is not completed or flash is busy<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_INCONSISTENT_BLOCK, if the targeted block was not written properly<BR>
 *     E_EEPROM_XMC1_OPERATION_STATUS_INVALID_BLOCK, if the targeted block was invalidated<BR>
 *
 * \par<b>Description:</b><br>
 *  It is useful when the latest write is interrupted due to power failures and flash errors. If a block read results
 *  in error, calling this API will search for the very next previous copy in the same bank. If the block is available
 *  then the user buffer will be filled with the data as per the requested length and offset. If the just previous
 *  copy of the data block is also inconsistent or invalid, no search will be done further.
 *
 *  <b>IMPORTANT : </b> This API do not perform any CRC verification for the read data.
 *
 *  <b>NOTE :</b><BR> If the flash is in busy state, the read will not be accepted.
 *
 */
 E_EEPROM_XMC1_OPERATION_STATUS_t E_EEPROM_XMC1_GetPreviousData(uint8_t block_number,
                                                               uint32_t block_offset,
                                                               uint8_t *data_buffer_ptr,
                                                               uint32_t length );

/**
 *@}
 */

#ifdef __cplusplus
}
#endif


#endif /* E_EEPROM_XMC1_H_ */
