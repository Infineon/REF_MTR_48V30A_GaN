/******************************************************************************
* File Name:   e_eeprom_xmc4.h
*
* Description: Header file for emulated EEPROM implementation in XMC4000 MCUs.
* It contains the necessary macro and structure definitions to use configure
* flash memory as emulated EEPROM.
*
* Related Document: See README.md
*
******************************************************************************
*
* Copyright (c) 2015-2021, Infineon Technologies AG
* All rights reserved.
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer,
* must be included in all copies of the Software, in whole or in part, and
* all derivative works of the Software, unless such copies or derivative
* works are solely in the form of machine-executable object code generated by
* a source language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
*
* Change History
* --------------
*
* 2016-01-20
*     - Initial version
*
* 2016-02-05
*     - XMC_LIB (LLD) version check corrected in header file
*
* 2016-07-08:
*     - Fixed incorrect case for an included header.<br>
*
* 2017-02-16:
*     - E_EEPROM_XMC4_WriteByte() and E_EEPROM_XMC4_WriteArray() returns a
*     boolean indicating if changes were detected since the last write to
*     the same area <BR>
*
* 2022-03-02:
*     - Adapted for use with mtb-xmc-emeeprom asset
*****************************************************************************/

#ifndef E_EEPROM_XMC4_H
#define E_EEPROM_XMC4_H

/****************************************************************************
 * HEADER FILES
 ***************************************************************************/
/**
********************************************************************************
* \mainpage Em_EEPROM Middleware Library
*
* The Emulated EEPROM (Em_EEPROM) middleware emulates an EEPROM storage in
* XMC4xxxx internal flash memory. The Em_EEPROM middleware operates on the top
* of the flash driver included in the XMCLib CAT3 Peripheral Driver Library.
*
* Use the Em_EEPROM to store non-volatile data on a target device when
* increasing flash memory endurance is important.
*
* Please note the Internal Flash is reserved by EEPROM middleware when using
* this asset and update the Linker script appropriately is required.
*
* <b>Features:</b>
* * EEPROM-Like Non-Volatile Storage
* * Easy to use Read and Write
*
********************************************************************************
* \section section_em_eeprom_general_description General Description
********************************************************************************
*
* The XMC4000 emulated EEPROM support is provided with the APIs described
* below.
*
* It should be noted that the non-volatile memory required to store the EEPROM
* Data is mapped to Internal Flash. In the XMC 4xxx emulated EEPROM Middleware
* the Flash region required for EEPROM Middleware is 64 KBytes of flash and is
* reserved from offset of 0x10000 from the Base of Flash. This is FIXED and
* cannot be changed. When adding this Middleware asset to a application, users
* are required to update/modify the application linker script to exclude this
* flash region from the memory used for application code/initialized data.
* So the FIRST 64 KBytes of Flash and flash beyond 128 KBytes of Flash can be
* used for code and initialized data in application. Examples of how to modify
* the Linker script create the memory hole of 64 KBytes starting at 64 KBytes
* from start of flash is provided in this documentation.
*
*
********************************************************************************
* \section section_em_eeprom_linker_script_update Linker Script Updates
********************************************************************************
*
* It should be noted that the non-volatile memory required to store the EEPROM
* Data is mapped to Internal Flash. In the XMC 4xxx emulated EEPROM Middleware
* the 64 KBytes of Flash region required for EEPROM is allocated from 0x10000
* from start of Flash till 0x20000 from start of Flash. The amount of Flash
* space reserved (64 KBytes) is fixed and its location CANNOT be changed.
* It is advisable for user(s) of emulated EEPROM to update their Linker file
* (script) to Not use the Flash space reserved for EEPROM for code/initialized
* data of application. A properly updated Linker script will remove
* the Flash region reserved for EEPROM from being used by linker for code
* or initialized data.
*
* For the Kit/XMC device you are using, please select the proper Linker script.
* For Infineon ModusToolbox targets, the GCC_ARM and ARM linker scripts are
* present in target for the kit under TOOLCHAIN_GCC_ARM and TOOLCHAIN_ARM.
* For IAR, please make a copy of the IAR linker script from the IAR toolchain
* and edit it for the Project using XMC4xxx Emulated EEPROM.
* Note - the ModusToolBox allows use of custom Linker script by editing in
* Makefile the tag LINKER_SCRIPT=\<path to custom linker script\>.
*
* Examples of how the linker scripts be modified is provided below.
*
* Note: EEPROM Middleware reserves 64 KBytes of Flash from offset 0x10000
* to 0x20000 from start of Flash memory. So a memory region hole has to be
* created in Linker script memory map, so that memory will Not be used
* by linker for code or initialized data..
*
* Note: The Vector table has to be mapped at start of Flash memory as the Reset
* Vector is the first entry in the Vector table.
*
* The above two constraints can be seen in examples of modified linker scripts
* below.
*
*
* Example of GCC_ARM Linker script for XMC4200x256 Kit/Device (XMC4200x256.ld):
*
* Original Linker script Memory map and sections:
*
* \code
*
* MEMORY
* {
*         FLASH_1_cached(RX) : ORIGIN = 0x08000000, LENGTH = 0x40000
*         FLASH_1_uncached(RX) : ORIGIN = 0x0C000000, LENGTH = 0x40000
*         PSRAM_1(!RX) : ORIGIN = 0x1FFFC000, LENGTH = 0x4000
*         DSRAM_1_system(!RX) : ORIGIN = 0x20000000, LENGTH = 0x6000
*         SRAM_combined(!RX) : ORIGIN = 0x1FFFC000, LENGTH = 0xA000
* }
*
*
* SECTIONS
* {
*
*   .text :
*  {
*    sText = .;
*    KEEP(*(.reset));
*    *(.text .text.* .gnu.linkonce.t.*);
*
*    KEEP(*(.init))
*    KEEP(*(.fini))
*
*
*    *crtbegin.o(.ctors)
*    *crtbegin?.o(.ctors)
*    *(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
*    *(SORT(.ctors.*))
*    *(.ctors)
*
*
*    *crtbegin.o(.dtors)
*    *crtbegin?.o(.dtors)
*    *(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
*    *(SORT(.dtors.*))
*    *(.dtors)
*
*    *(.rodata .rodata.*)
*    *(.gnu.linkonce.r*)
*
*    *(vtable)
*
*    . = ALIGN(4);
*  } > FLASH_0_cached AT > FLASH_0_uncached
* \endcode
*
* Modified Linker script Memory map and sections:
*
* \code
*
* MEMORY
* {
*         FLASH_0_cached(RX) : ORIGIN = 0x08000000, LENGTH = 0x10000
*         FLASH_1_uncached(RX) : ORIGIN = 0x0C000000, LENGTH = 0x10000
*         FLASH_1_cached(RX) : ORIGIN = 0x08020000, LENGTH = 0x20000
*         FLASH_1_uncached(RX) : ORIGIN = 0x0C020000, LENGTH = 0x20000
*         PSRAM_1(!RX) : ORIGIN = 0x1FFFC000, LENGTH = 0x4000
*         DSRAM_1_system(!RX) : ORIGIN = 0x20000000, LENGTH = 0x6000
*         SRAM_combined(!RX) : ORIGIN = 0x1FFFC000, LENGTH = 0xA000
* }
*
*
* SECTIONS
* {
*
*
*   .reset :
*   {
*     KEEP(*(.reset));
*   } > FLASH_0_cached AT > FLASH_0_uncached
*
*   .text :
*   {
*     sText = .;
*     *(.text .text.* .gnu.linkonce.t.*);
*
*
*     KEEP(*(.init))
*     KEEP(*(.fini))
*
*
*     *crtbegin.o(.ctors)
*     *crtbegin?.o(.ctors)
*     *(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors)
*     *(SORT(.ctors.*))
*     *(.ctors)
*
*
*     *crtbegin.o(.dtors)
*     *crtbegin?.o(.dtors)
*     *(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors)
*     *(SORT(.dtors.*))
*     *(.dtors)
*
*     *(.rodata .rodata.*)
*     *(.gnu.linkonce.r*)
*
*     *(vtable)
*
*     . = ALIGN(4);
*   } > FLASH_1_cached AT > FLASH_1_uncached
* \endcode
*
*
* Note: There is Gap in memory map for offset 0x10000 (64 KBytes into Flash)
* and for length: 0x10000 (64 KBytes).
*
*
* Example of ARM Linker script for XMC4200x256 Kit/Device (XMC4200x256.sct):
*
* Original Linker script Memory map and load:
*
* \code
*
* #define __ROM_BASE     0x08000000
* #define __ROM_SIZE     0x00040000
*
*
* #define __RO_BASE         __ROM_BASE
* #define __RO_SIZE         __ROM_SIZE
*
* #define __NO_INIT         64
*
* LR_ROM __RO_BASE __RO_SIZE  {                       ; load region size_region
*   ER_ROM __RO_BASE __RO_SIZE  {                     ; load address = execution address
*    *.o (RESET, +First)
*    *(InRoot$$Sections)
*    .ANY (+RO)
*    .ANY (+XO)
*   }
*
* \endcode
*
*
* Modified Linker script Memory map and load:
*
*
* \code
*
* #define __ROM_BASE     0x08000000
* #define __ROM_SIZE     0x00010000
*
* #define __ROM1_BASE     0x08020000
* #define __ROM1_SIZE     0x00020000
*
*
*
* #define __RO_BASE         __ROM_BASE
* #define __RO_SIZE         __ROM_SIZE
*
* #define __R1_BASE         __ROM1_BASE
* #define __R1_SIZE         __ROM1_SIZE
*
* #define __NO_INIT         64
*
* LR_ROM __RO_BASE __RO_SIZE  {                       ; load region size_region
*   ER_ROM __RO_BASE __RO_SIZE  {                     ; load address = execution address
*    *.o (RESET, +First)
*   }
* }
*
* LR_ROM_1 __R1_BASE __R1_SIZE  {                       ; load region size_region
*   ER_ROM_1 __R1_BASE __R1_SIZE  {                     ; load address = execution address
*    *(InRoot$$Sections)
*    .ANY (+RO)
*    .ANY (+XO)
*   }
* }
*
* \endcode
*
*
*
* Example of IAR Linker script for XMC4200x256 Kit/Device (XMC4200xxxx256.icf):
*
* Original Linker script Memory map:
*
* \code
*
* define symbol __ICFEDIT_region_ROM_start__ = 0x08000000;
* define symbol __ICFEDIT_region_ROM_end__   = 0x0803FFFF;
*
*
* define region ROM_region   = mem:[from __ICFEDIT_region_ROM_start__ to __ICFEDIT_region_ROM_end__];
*
* place at address mem:__ICFEDIT_intvec_start__ {readonly section .intvec};
*
* place in ROM_region  {readonly};
*
*
* \endcode
*
*
* Modified Linker script Memory map:
*
*
* \code
*
* define symbol __ICFEDIT_region_ROM_start__ = 0x08000000;
* define symbol __ICFEDIT_region_ROM_end__   = 0x08010000;
* define symbol __ICFEDIT_region_ROM_1_start__ = 0x08020000;
* define symbol __ICFEDIT_region_ROM_1_end__   = 0x0803FFFF;
*
*
* define region ROM_region   = mem:[from __ICFEDIT_region_ROM_start__ to __ICFEDIT_region_ROM_end__];
* define region ROM_1_region   = mem:[from __ICFEDIT_region_ROM_1_start__ to __ICFEDIT_region_ROM_1_end__];
*
* place at address mem:__ICFEDIT_intvec_start__ {readonly section .intvec};
*
* place in ROM_region  {readonly object main.o};
* place in ROM_1_region  {readonly};
* \endcode
*
*
* Example of GCC_ARM Linker script for XMC4100x128 Kit/Device:
*
* Note: Since this device has Only 128 KBytes of Flash, if EEPROM is
* used on this device, the only available Flash for Code and Initialized
* data will be the first 64 KBytes, as the 2nd 64 KBytes of Flash will
* be reserved for EEPROM. So the modification to the linker script
* is to map only the first 64 KBytes for code and initialized data.
* The modification to linker script will be similar to changes shown
* in detail for XMC 1xxx EEPROM. Below is the example of change for
* GCC_ARM Linker script.
*
* Original Linker script Memory map and sections (XMC4100x128.ld):
*
* \code
*
* MEMORY
* {
*         FLASH_1_cached(RX) : ORIGIN = 0x08000000, LENGTH = 0x20000
*         FLASH_1_uncached(RX) : ORIGIN = 0x0C000000, LENGTH = 0x20000
*         PSRAM_1(!RX) : ORIGIN = 0x1FFFE000, LENGTH = 0x2000
*         DSRAM_1_system(!RX) : ORIGIN = 0x20000000, LENGTH = 0x3000
*         SRAM_combined(!RX) : ORIGIN = 0x1FFFE000, LENGTH = 0x5000
* }
*
* \endcode
*
* Modified Linker script Memory map and sections:
*
* \code
*
* MEMORY
* {
*         FLASH_1_cached(RX) : ORIGIN = 0x08000000, LENGTH = 0x10000
*         FLASH_1_uncached(RX) : ORIGIN = 0x0C000000, LENGTH = 0x10000
*         PSRAM_1(!RX) : ORIGIN = 0x1FFFE000, LENGTH = 0x2000
*         DSRAM_1_system(!RX) : ORIGIN = 0x20000000, LENGTH = 0x3000
*         SRAM_combined(!RX) : ORIGIN = 0x1FFFE000, LENGTH = 0x5000
* }
*
* \endcode
*
*
*
********************************************************************************
* \section section_em_eeprom_app_usage Application Configuration and API Usage
********************************************************************************
*
* 
* The XMC4 Emulated EEPROM asset can used to store non-volatile data
* in Flash with improved resiliency. In XMC4 emulated eeprom asset the
* Flash used for mapping the user data to flash is fixed and cannot
* be changed. It is mapped from offset of 64 KBytes (0x10000) for
* length of 64 KBytes. Before using emulated EEPROM asset, the
* Flash in the region Device Flash Base + 0x10000 to
* Device Flash Base + 0x20000 should be erased and have No data
* present in it. Since EEPROM retains data between subsequent
* power-cycles/reboots and re-programming of application. This region
* should not be erased unless it is explicitly desired to get rid
* of previously stored data.
* 
* The XMC4 EEPROM configuration data is just the "len" of EEPROM
* which is passed to the initialization API.
* 
* The typical application programming sequence for using the eeprom
* asset is to initially call the API:
* 
* E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_Init(E_EEPROM_XMC4_t *const handle, uint32_t len);
* 
* Passing in the "E_EEPROM_XMC4_t *const handle" data structure which
* has only a Boolean variable. This is typically "false" when passed
* to this Initialization function.
* 
* After that the XMC4 provided APIs for Read/Write APIs
* (Byte or Array APIs) can be called. When it is desired to store
* the updated data to Flash (non-volatile), the API:
* E_EEPROM_XMC4_UpdateFlashContents() should be called.
* It should be noted that any Writes between 2 calls to
* E_EEPROM_XMC4_UpdateFlashContents() is only stored in RAM and not
* written to flash (non-volatile).
*
*
********************************************************************************
*
* \defgroup E_EEPROM_XMC4_enumerations Enumerations
* \brief
* This section describes the Emulated EEPROM Macros.
*
* \defgroup E_EEPROM_XMC4_datastructures Data Structures
* \brief
* This section describes the data structures defined by the Emulated EEPROM.
*
* \defgroup E_EEPROM_XMC4_functions Functions
* \brief
* This section describes the public APIs defined by the Emulated EEPROM.
*
*
*/

#include "xmc_flash.h"
#include "xmc_fce.h"

/****************************************************************************
 * MACROS
****************************************************************************/

/****************************************************************************
* ENUMS
****************************************************************************/
/**
* \addtogroup E_EEPROM_XMC4_enumerations
* \{
*/

/** Defines the error codes for E_EEPROM_XMC4 application. Use @ref E_EEPROM_XMC4_STATUS_t type for accessing the member.  */

typedef enum E_EEPROM_XMC4_STATUS
{
  E_EEPROM_XMC4_STATUS_OK                 = 0U, /**< Successful completion of initialization */
  E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA     = 1U, /**< Initialization succeeded with old data block. Latest has been found
                                                     corrupted or half programmed in previous power down cycle write. */
  E_EEPROM_XMC4_STATUS_READ_ERROR         = 2U, /**< Initialization failed due to read error */
  E_EEPROM_XMC4_STATUS_WRITE_ERROR        = 3U, /**< Initialization failed due to write error */
  E_EEPROM_XMC4_STATUS_ERASE_ERROR        = 4U, /**< Initialization failed due to erase error */
  E_EEPROM_XMC4_STATUS_ERROR_PARAM        = 5
} E_EEPROM_XMC4_STATUS_t;

/**
 *@}
 */
/**
* \addtogroup E_EEPROM_XMC4_datastructures
* \{
*/

/****************************************************************************
* DATA STRUCTURES
****************************************************************************/
/**
* @brief Initialization data structure of E_EEPROM_XMC4 APP
*/

typedef struct E_EEPROM_XMC4
{
  bool initialized;                           /**< Initialization status */
} E_EEPROM_XMC4_t;

/**
 *@}
 */

/****************************************************************************
 * API Prototypes
 ***************************************************************************/
#ifdef __cplusplus
extern "C"  {
#endif

/**
* \addtogroup E_EEPROM_XMC4_functions
* \{
*/

/**
 * @brief Initializes flash emulated EEPROM to start read and write operations.
 * @param handle  Handle for XMC EEProm block with status of Initialization
 * @param len     Size of emulated EEPROM
 *
 * @return E_EEPROM_XMC4_STATUS_OK, if Initialization succeeds, Else\n
 *         E_EEPROM_XMC4_STATUS_WRITE_ERROR, if initialization failed due to write error.
 *         E_EEPROM_XMC4_STATUS_ERASE_ERROR, if erase failed during initialization process.
 *         E_EEPROM_XMC4_STATUS_ERROR_OLD_DATA, if initialization succeeded with old data block. Latest has been found
 *                                              corrupted or half programmed in previous power down cycle write.
 *
 * \par<b>Description:</b><br>
 * Initializes Flash Emulated EEPROM application.\n
 * It checks for the latest written block starting from logical SECTOR 7 to SECTOR 4. If a latest block is identified
 * among any 4 sectors, the block gets copied to RAM. Hence it can be read any time from RAM. If no blocks identified,
 * SECTOR 4 is considered as current active sector for future writes. \n If more than one SECTOR has data blocks, all
 * sectors apart from the sector having the latest data block are erased. In this process, any flash errors results in
 * "E_EEPROM_XMC4_STATUS_ERASE_ERROR" state.\n  If the sector having the latest block doesn't have any free space, the Init
 * process will copy the latest block into new free sector and erase the old sector. If the copy process results in
 * flash write errors or when all sectors filled up, it returns the status \a E_EEPROM_XMC4_STATUS_WRITE_ERROR.
 *
 * \par<b>Related APIs:</b><BR>
 * None \n
 *
 */
 E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_Init(E_EEPROM_XMC4_t *const handle,  uint32_t len);

/**
 * @brief Update a particular byte in the RAM copy of data block.
 * @param offset_address RAM Offset address, where the data shall be written.
 * @param value          8bit data to be written into the RAM buffer.
 *
 * @return Boolean indicating if changes were detected since the last write to the address
 *
 * \par<b>Description:</b><br>
 * Write a particular byte into the RAM buffer. Sets up the internal RAM buffer with data elements
 * which are targeted to be written into emulated flash area.\n
 *
 *<b>Related APIs : </b><BR>  None\n\n
 *
 */
 bool E_EEPROM_XMC4_WriteByte(const uint16_t offset_address, const uint8_t value);

/**
 * @brief Update a set of bytes in the RAM copy of data block.
 * @param offset_address RAM Offset address from where the data write shall be started.
 * @param data           Constant pointer to array of 8bit data.
 * @param length         Length of the data array (specify the number bytes to be written).
 *
 * @return Boolean indicating if changes were detected since the last write to the same area
 *
 * \par<b>Description:</b><br>
 * Write an array of data elements into the RAM buffer.\n
 *
 *<b>Related APIs : </b><BR>  None\n\n
 *
 */
 bool E_EEPROM_XMC4_WriteArray(const uint16_t offset_address, const uint8_t *const data, const uint16_t length);

/**
 * @brief Reads a particular byte from the RAM copy of data block.
 * @param offset_address RAM Offset address from where the data read shall be started.
 * @param value          Constant pointer to 8bit data variable (address of variable).
 *
 *
 * @return None
 *
 * \par<b>Description:</b><br>
 * Read a particular byte from the RAM buffer.\n
 *
 *<b>Related APIs : </b><BR>  None\n\n
 *
 */
 void E_EEPROM_XMC4_ReadByte(const uint16_t offset_address, uint8_t *const value);

/**
 * @brief Reads a set of bytes from the RAM copy of data block.
 * @param offset_address RAM Offset address from where the data read shall be started.
 * @param data           Constant pointer to array of 8bit data variable.
 * @param length         Length of the data array (specify the number bytes to be read).
 *
 * @return None
 *
 * \par<b>Description:</b><br>
 * Read an array of data elements from the RAM buffer.\n
 *
 * \par<b>Related APIs:</b><BR>
 * None\n
 *
 */
 void E_EEPROM_XMC4_ReadArray(const uint16_t offset_address, uint8_t *const data, const uint16_t length);

/**
 * @brief Programs the flash with the latest data block available in RAM.
 * @param :
 *
 * @return E_EEPROM_XMC4_STATUS_OK, if flash programming succeeds, Else\n
 *         E_EEPROM_XMC4_STATUS_WRITE_ERROR, fails due to flash write error or \n
 *         E_EEPROM_XMC4_STATUS_ERASE_ERROR, fails due to flash erase operation when all sectors are filled up.
 *
 * \par<b>Description:</b><br>
 * Programs the RAM buffer into emulated area of the FLASH. On successful completion of this API, the data block
 * gets saved in the flash. Hence data retention is possible over reset cycles. Call this API only in the POWER
 * DOWN cycle to ensure the flash endurance.
 *
 * \par<b>Related APIs:</b><BR>
 * None\n
 *
 */
 E_EEPROM_XMC4_STATUS_t E_EEPROM_XMC4_UpdateFlashContents(void);

/**
 * @brief Check at least one data block is available in the flash emulated EEPROM.
 * @param :
 *
 * @return  <BR>
 *        true, if the flash is empty
 *        else returns false.
 *
 * \par<b>Description:</b><br>
 *  During first time of the execution, flash can be programmed with data by checking this API status.
 *
 * \par<b>Related APIs:</b><BR>
 *  None\n
 *
 */
 bool E_EEPROM_XMC4_IsFlashEmpty(void);

/**
 *@}
 */

#ifdef __cplusplus
}
#endif

#endif /* E_EEPROM_XMC4_H */

